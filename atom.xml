<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>安静-不安静的博客</title>
  
  <link href="https:///AnJingwd.github.io/atom.xml" rel="self"/>
  
  <link href="https:///AnJingwd.github.io/"/>
  <updated>2017-08-19T10:56:56.020Z</updated>
  <id>https:///AnJingwd.github.io/</id>
  
  <author>
    <name>AJ&#39;s blog</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何优雅的生成及遍历python嵌套字典</title>
    <link href="https:///AnJingwd.github.io/2017/08/19/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%94%9F%E6%88%90python%E5%B5%8C%E5%A5%97%E5%AD%97%E5%85%B8/"/>
    <id>https:///AnJingwd.github.io/2017/08/19/如何优雅的生成python嵌套字典/</id>
    <published>2017-08-19T07:41:32.000Z</published>
    <updated>2017-08-19T10:56:56.020Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">如何优雅的生成及遍历python嵌套字典</blockquote>

<a id="more"></a>
<h1 id="嵌套字典生成"><a href="#嵌套字典生成" class="headerlink" title="嵌套字典生成"></a>嵌套字典生成</h1><h2 id="方法一-定义类"><a href="#方法一-定义类" class="headerlink" title="方法一:定义类"></a>方法一:定义类</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vividict</span><span class="params">(dict)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></div><div class="line">		value = self[key] = type(self)()</div><div class="line">		<span class="keyword">return</span> value</div></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>第一行：class后面紧接着是类名，即Vividict，类名通常是大写开头的单词，紧接着是(dict)，表示该类是dict类继承下来的。</li>
</ul>
<p>我们可以使用dir(dict）查看dict的方法<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In[<span class="number">22</span>]: print(dir(dict))</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'fromkeys'</span>, <span class="string">'get'</span>, <span class="string">'items'</span>, <span class="string">'keys'</span>, <span class="string">'pop'</span>, <span class="string">'popitem'</span>, <span class="string">'setdefault'</span>, <span class="string">'update'</span>, <span class="string">'values'</span>]</div></pre></td></tr></table></figure></p>
<p>同理，可以查看Vividict的方法<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In[<span class="number">23</span>]: print(dir(Vividict))</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__missing__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'fromkeys'</span>, <span class="string">'get'</span>, <span class="string">'items'</span>, <span class="string">'keys'</span>, <span class="string">'pop'</span>, <span class="string">'popitem'</span>, <span class="string">'setdefault'</span>, <span class="string">'update'</span>, <span class="string">'values'</span>]</div></pre></td></tr></table></figure></p>
<p>比较两者可以发现，Vividict的方法比dict的方法多了一个<strong>missing</strong>方法，也就是我们添加的方法。所以这就是继承，继承最大的好处是子类获得了父类的全部功能，而不必重新造轮子。</p>
<ul>
<li><p>第二行：python魔法方法中的自定义序列，类似于定义一个函数。<strong>missing</strong> 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， “george” 不是字典中的一个键，当试图访问 d[‘george’] 时就会调用 d.<strong>missing</strong>(“george”)，结果为{} ）。</p>
</li>
<li><p>第三行，第四行：访问字典中不存在的键(key)时，返回空字典作为其返回值（value）</p>
</li>
</ul>
<p>例如：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">In[<span class="number">17</span>]: a = dict()</div><div class="line">In[<span class="number">18</span>]: type(a)()</div><div class="line">Out[<span class="number">18</span>]: </div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li>特殊方法“missing”前后有两个下划线！！！</li>
<li>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</li>
</ul>
<p>使用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment">#导入模块</span></div><div class="line"><span class="keyword">import</span> os, openpyxl</div><div class="line"><span class="keyword">import</span> pprint</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</div><div class="line"></div><div class="line"><span class="comment">#pprint模块可以输出漂亮的字典结构，但是不利于后期利用R作图</span></div><div class="line"><span class="comment">#DataFrame可以将字典结构转为数据框输出，方便后期利用R作图</span></div><div class="line"></div><div class="line"><span class="comment">#切换工作路径</span></div><div class="line">os.chdir(<span class="string">r'F:\pycharm_project\mutation_count'</span>)</div><div class="line"></div><div class="line"><span class="comment">#读取excel表格</span></div><div class="line">wb = openpyxl.load_workbook(<span class="string">'东方肝胆数据综合.xlsx'</span>)</div><div class="line">sheet = wb.active</div><div class="line"></div><div class="line"><span class="comment">#定义类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vividict</span><span class="params">(dict)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></div><div class="line">		value = self[key] = type(self)()</div><div class="line">		<span class="keyword">return</span> value</div><div class="line"></div><div class="line"><span class="comment">#实例化</span></div><div class="line">d = Vividict()</div><div class="line"></div><div class="line"><span class="comment">#字典初始化，赋初值0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,sheet.max_row+<span class="number">1</span>):</div><div class="line">	d[sheet.cell(row=i, column=<span class="number">1</span>).value][sheet.cell(row=i, column=<span class="number">15</span>).value] = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="comment">#累加统计各个样本各种突变类型的数目</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,sheet.max_row+<span class="number">1</span>):</div><div class="line">	d[sheet.cell(row=i, column=<span class="number">1</span>).value][sheet.cell(row=i, column=<span class="number">15</span>).value] +=<span class="number">1</span></div><div class="line"></div><div class="line">pprint.pprint(d)</div><div class="line"></div><div class="line"><span class="comment">#输出字典结构</span></div><div class="line"></div><div class="line">pprint.pprint(d)</div><div class="line"></div><div class="line">&#123;<span class="string">'PDC1279A_vs_PDC1279'</span>: &#123;<span class="string">'UTR3'</span>: <span class="number">9</span>,</div><div class="line">                         <span class="string">'UTR5'</span>: <span class="number">4</span>,</div><div class="line">                         <span class="string">'downstream'</span>: <span class="number">5</span>,</div><div class="line">                         <span class="string">'exonic'</span>: <span class="number">149</span>,</div><div class="line">                         <span class="string">'intergenic'</span>: <span class="number">170</span>,</div><div class="line">                         <span class="string">'intronic'</span>: <span class="number">163</span>,</div><div class="line">                         <span class="string">'ncRNA_exonic'</span>: <span class="number">17</span>,</div><div class="line">                         <span class="string">'ncRNA_intronic'</span>: <span class="number">23</span>,</div><div class="line">                         <span class="string">'splicing'</span>: <span class="number">2</span>,</div><div class="line">                         <span class="string">'upstream;downstream'</span>: <span class="number">2</span>&#125;,</div><div class="line"> <span class="string">'PDC1279C_vs_PDC1279'</span>: &#123;<span class="string">'UTR3'</span>: <span class="number">11</span>,</div><div class="line">                         <span class="string">'UTR5'</span>: <span class="number">13</span>,</div><div class="line">                         <span class="string">'downstream'</span>: <span class="number">1</span>,</div><div class="line">                         <span class="string">'exonic'</span>: <span class="number">174</span>,</div><div class="line">                         <span class="string">'intergenic'</span>: <span class="number">189</span>,</div><div class="line">                         <span class="string">'intronic'</span>: <span class="number">172</span>,</div><div class="line">                         <span class="string">'ncRNA_exonic'</span>: <span class="number">24</span>,</div><div class="line">                         <span class="string">'ncRNA_intronic'</span>: <span class="number">36</span>,</div><div class="line">                         <span class="string">'splicing'</span>: <span class="number">4</span>,</div><div class="line">                         <span class="string">'upstream'</span>: <span class="number">2</span>,</div><div class="line">                         <span class="string">'upstream;downstream'</span>: <span class="number">2</span>&#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">#输出数据框结构，缺损的元素用 NaN补齐</span></div><div class="line"></div><div class="line">frame = DataFrame(d)</div><div class="line">print(frame)</div><div class="line"></div><div class="line">                     PDC1279A_vs_PDC1279  PDC1279C_vs_PDC1279  \</div><div class="line">UTR3                                 <span class="number">9.0</span>                 <span class="number">11.0</span>   </div><div class="line">UTR5                                 <span class="number">4.0</span>                 <span class="number">13.0</span>   </div><div class="line">downstream                           <span class="number">5.0</span>                  <span class="number">1.0</span>   </div><div class="line">exonic                             <span class="number">149.0</span>                <span class="number">174.0</span>   </div><div class="line">exonic;splicing                      NaN                  NaN   </div><div class="line">intergenic                         <span class="number">170.0</span>                <span class="number">189.0</span>   </div><div class="line">intronic                           <span class="number">163.0</span>                <span class="number">172.0</span>   </div><div class="line">ncRNA_exonic                        <span class="number">17.0</span>                 <span class="number">24.0</span>   </div><div class="line">ncRNA_intronic                      <span class="number">23.0</span>                 <span class="number">36.0</span>   </div><div class="line">ncRNA_splicing                       NaN                  NaN   </div><div class="line">splicing                             <span class="number">2.0</span>                  <span class="number">4.0</span>   </div><div class="line">upstream                             NaN                  <span class="number">2.0</span>   </div><div class="line">upstream;downstream                  <span class="number">2.0</span>                  <span class="number">2.0</span></div></pre></td></tr></table></figure>
<h2 id="方法二：使用defaultdict"><a href="#方法二：使用defaultdict" class="headerlink" title="方法二：使用defaultdict()"></a>方法二：使用defaultdict()</h2><p>两个维度字典：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line">d = defaultdict(defaultdict)</div><div class="line">d[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>等价于：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nested_dict_factory</span><span class="params">()</span>:</span> </div><div class="line">    <span class="keyword">return</span> defaultdict(int)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">nested_dict_factory2</span><span class="params">()</span>:</span> </div><div class="line">    <span class="keyword">return</span> defaultdict(nested_dict_factory)</div><div class="line"></div><div class="line">db = defaultdict(nested_dict_factory2)</div></pre></td></tr></table></figure>
<p>当然，第一种方法简洁的多！</p>
<p>要获得更多维度，你可以（三维）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</div><div class="line">d = defaultdict(<span class="keyword">lambda</span> :defaultdict(defaultdict))</div><div class="line">d[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>] = <span class="number">4</span></div></pre></td></tr></table></figure>
<p>使用defaultdict任何未定义的key都会默认返回一个根据method_factory参数不同的默认值, 而相同情况下dict()会返回KeyError.</p>
<p>python中lambda存在意义就是对简单函数的简洁表示</p>
<p>实际上 defaultdict也是通过<strong>missing</strong>方法实现的。defaultdict在dict的基础上添加了一个missing(key)方法, 在调用一个不存的key的时候, defaultdict会调用<strong>missing</strong>, 返回一个根据default_factory参数的默认值, 所以不会返回Keyerror.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">In[<span class="number">35</span>]: print(dir(defaultdict))</div><div class="line">[<span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__copy__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__delitem__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__missing__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setitem__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'clear'</span>, <span class="string">'copy'</span>, <span class="string">'default_factory'</span>, <span class="string">'fromkeys'</span>, <span class="string">'get'</span>, <span class="string">'items'</span>, <span class="string">'keys'</span>, <span class="string">'pop'</span>, <span class="string">'popitem'</span>, <span class="string">'setdefault'</span>, <span class="string">'update'</span>, <span class="string">'values'</span>]</div></pre></td></tr></table></figure>
<h1 id="嵌套字典的遍历"><a href="#嵌套字典的遍历" class="headerlink" title="嵌套字典的遍历"></a>嵌套字典的遍历</h1><h2 id="方法一：一层一层的嵌套迭代-从而实现遍历"><a href="#方法一：一层一层的嵌套迭代-从而实现遍历" class="headerlink" title="方法一：一层一层的嵌套迭代,从而实现遍历"></a>方法一：一层一层的嵌套迭代,从而实现遍历</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> d.items():</div><div class="line">    <span class="keyword">for</span> key2, val2 <span class="keyword">in</span> value.items():</div><div class="line">        <span class="keyword">print</span> (key2, val2)</div></pre></td></tr></table></figure>
<h1 id="在类中定义walk方法实现嵌套字典的遍历"><a href="#在类中定义walk方法实现嵌套字典的遍历" class="headerlink" title="在类中定义walk方法实现嵌套字典的遍历"></a>在类中定义walk方法实现嵌套字典的遍历</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vividict</span><span class="params">(dict)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></div><div class="line">		value = self[key] = type(self)()</div><div class="line">		<span class="keyword">return</span> value</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">walk</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">for</span> key, value <span class="keyword">in</span> self.items():</div><div class="line">			<span class="keyword">if</span> isinstance(value, Vividict):</div><div class="line">				<span class="keyword">for</span> tup <span class="keyword">in</span> value.walk():</div><div class="line">					<span class="keyword">yield</span> (key,) + tup</div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				<span class="keyword">yield</span> key, value</div></pre></td></tr></table></figure>
<p>解释:<br>第1-4行：上面已经解释过了<br>第5-11行：定义一个walk函数，并对字典items对象的key和value进行遍历，isinstance用于判断对象类型，如果value是一个字典，那么对value调用walk（）方法继续进行遍历，一层一层将key,value存储在元祖中（）。当最里面一层，即else情况，输出key,value。整个过程即<strong>将字典数据结构扁平化为元祖</strong></p>
<p>此时，我们可以这样来遍历字典（输出元祖）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#打印整个元祖</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> d.walk():</div><div class="line">	print(tup)</div><div class="line"></div><div class="line">(<span class="string">'PDC1279_vs_PDC1279C6'</span>, <span class="string">'downstream'</span>, <span class="number">3</span>)</div><div class="line">(<span class="string">'PDC1279_vs_PDC1279C6'</span>, <span class="string">'UTR3'</span>, <span class="number">11</span>)</div><div class="line">(<span class="string">'PDC1279_vs_PDC1279C6'</span>, <span class="string">'intronic'</span>, <span class="number">164</span>)</div><div class="line">(<span class="string">'PDC1279_vs_PDC1279C6'</span>, <span class="string">'splicing'</span>, <span class="number">4</span>)</div><div class="line"></div><div class="line">**这就是扁平化的字典**</div><div class="line"></div><div class="line"><span class="comment">#打印元祖的第3列</span></div><div class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> d.walk():</div><div class="line">	print(tup[<span class="number">2</span>])</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>（1）<a href="https://ask.helplib.com/229754" target="_blank" rel="external">https://ask.helplib.com/229754</a></p>
<p>（2）Python魔法方法指南（推荐阅读）</p>
<p><a href="http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html" target="_blank" rel="external">http://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;如何优雅的生成及遍历python嵌套字典&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https:///AnJingwd.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https:///AnJingwd.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>常用链接（持续更新）</title>
    <link href="https:///AnJingwd.github.io/2017/08/19/%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https:///AnJingwd.github.io/2017/08/19/常用链接（持续更新）/</id>
    <published>2017-08-19T06:51:52.000Z</published>
    <updated>2017-08-24T09:57:43.029Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">常用链接（持续更新）</blockquote>

<a id="more"></a>
<h1 id="网络生信课程"><a href="#网络生信课程" class="headerlink" title="网络生信课程"></a>网络生信课程</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.coursera.org/" target="_blank" rel="external">coursera</a></td>
<td>在网上学习全世界最好的课程</td>
</tr>
<tr>
<td><a href="http://mooc.guokr.com/course/575/Bioinformatics--Introduction-and-Methods/" target="_blank" rel="external">Bioinformatics: Introduction and Methods</a></td>
<td>北大MOOK生物信息学导论</td>
</tr>
<tr>
<td><a href="http://www.iqiyi.com/paopao/u/2154955599/playlist/" target="_blank" rel="external">陈魏学基因</a></td>
<td>NGS相关视频</td>
</tr>
<tr>
<td><a href="http://abc.cbi.pku.edu.cn/manuals.php" target="_blank" rel="external">Applied Bioinformatics Course </a></td>
<td>北大罗静初老师abc生信课程</td>
</tr>
<tr>
<td><a href="http://genomicsclass.github.io/book/" target="_blank" rel="external">Biomedical Data Science</a></td>
<td>统计，算法，NGS书籍</td>
</tr>
<tr>
<td><a href="https://cbsu.tc.cornell.edu/workshops.aspx" target="_blank" rel="external">Workshops</a></td>
<td>康奈尔大学生信课件（2010-2017）</td>
</tr>
<tr>
<td><a href="http://petang.cgu.edu.tw/Bioinfomatics/" target="_blank" rel="external">CGU-GIBMS</a></td>
<td>台湾长庚大学生信课件</td>
</tr>
<tr>
<td><a href="https://wikis.utexas.edu/display/bioiteam" target="_blank" rel="external">Bioinformatics Team (BioITeam) at the University of Texas</a></td>
<td>德州大学奥斯丁分校生信课件</td>
</tr>
<tr>
<td><a href="http://tanlab.ucdenver.edu/labHomePage/teaching/CANB7640/" target="_blank" rel="external">CANB7640 COURSE WEBSITE</a></td>
<td>生信课件-按研究内容分</td>
</tr>
<tr>
<td><a href="https://qcb.ucla.edu/collaboratory/workshops/" target="_blank" rel="external">UCLA</a></td>
<td>加利福尼亚大学洛杉矶分校NGS数据处理workshop最全合集</td>
</tr>
<tr>
<td><a href="https://www.bioinformatics.purdue.edu/discoverypark/cyber/bioinformatics/services/workshops.php" target="_blank" rel="external">Purdue university Discovery Park</a></td>
<td>普渡大学生物信息课程</td>
</tr>
<tr>
<td><a href="http://biology.umd.edu/bioinformatics-crash-course---july-2014.html" target="_blank" rel="external">Bioinformatics Crash Course - July 2014</a> &emsp; <a href="http://biology.umd.edu/rna-seq-analysis.html" target="_blank" rel="external">RNA-seq Analysis</a> &emsp; <a href="http://biology.umd.edu/linux-and-hpcc-workshop.html" target="_blank" rel="external">Linux and HPCC</a></td>
<td>马里兰大学的生信中心课程-NGS分析，RNA-seq分析，linux和高性能计算</td>
</tr>
<tr>
<td><a href="https://btiplantbioinfocourse.wordpress.com/" target="_blank" rel="external">BTI Bioinformatics Course 2017</a></td>
<td>美国康奈尔大学博伊斯汤普森植物研究所课件</td>
</tr>
<tr>
<td><a href="https://edu.isb-sib.ch/course/index.php?categoryid=5" target="_blank" rel="external">Swiss Institute of  Bioinformatics</a></td>
<td>瑞士生物信息学研究所8年培训资料</td>
</tr>
<tr>
<td><a href="http://biof-edu.colorado.edu/videos/dowell-short-read-class" target="_blank" rel="external">BioFrontiers Education</a></td>
<td>科罗拉多大学生物信息课程</td>
</tr>
<tr>
<td><a href="https://www.stat.berkeley.edu/~terry/Classes/s246.2006/" target="_blank" rel="external">Statistics 246 Statistical Genetics Spring 2006</a></td>
<td>伯克利大学的遗传统计学课程</td>
</tr>
<tr>
<td><a href="https://ngschool.eu/2016/workshops" target="_blank" rel="external">NGSchool 2016 Workshops</a></td>
<td>NGSchool非常全面的ppt</td>
</tr>
<tr>
<td><a href="http://bioinformatics.mdc-berlin.de/intro2UnixandSGE/index.html" target="_blank" rel="external">BIOINFORMATICS PLATFORM</a></td>
<td>德国柏林医学院中心生物信息学课程资料</td>
</tr>
<tr>
<td><a href="http://compbio.uthscsa.edu/jinlab/courses.shtml" target="_blank" rel="external">UT HEALTH SCIENCE CENTER</a></td>
<td>圣安东尼奥-生命健康中心-jin实验室生物信息学课程ppt</td>
</tr>
<tr>
<td><a href="http://www.mi.fu-berlin.de/w/ABI/Genomics12" target="_blank" rel="external">MSc lecture Genomics</a></td>
<td>柏林自由大学 Genomics12</td>
</tr>
<tr>
<td><a href="http://www.soph.uab.edu/ssg/courses/archives" target="_blank" rel="external">Statistical  Genetics</a> &emsp;<a href="http://www.soph.uab.edu/ssg/nhgri_r25/fifthshortcourse" target="_blank" rel="external">NGS</a> &emsp;<a href="http://www.soph.uab.edu/ssg/nigmsstatgen/fifth" target="_blank" rel="external">Statistical Genetics and Genomics</a></td>
<td>伯明翰阿拉巴马大学-生物信息视频教程</td>
</tr>
<tr>
<td><a href="http://www.bioinformatics.babraham.ac.uk/training.html" target="_blank" rel="external">Babraham Institute the Bioinformatics</a></td>
<td>伯拉罕研究所生信课程</td>
</tr>
<tr>
<td><a href="http://www.personal.psu.edu/iua1/courses/2014-BMMB-852.html" target="_blank" rel="external">Applied Bioinformatics 2014</a></td>
<td>biostar handbook-生信分析 </td>
</tr>
</tbody>
</table>
<h1 id="网络学编程及数据分析"><a href="#网络学编程及数据分析" class="headerlink" title="网络学编程及数据分析"></a>网络学编程及数据分析</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://togaware.com/onepager/" target="_blank" rel="external">OnePageR</a></td>
<td>A Survival Guide to Data Science with R</td>
</tr>
<tr>
<td><a href="http://kasperdanielhansen.github.io/genbioconductor/" target="_blank" rel="external">Bioconductor for Genomic Data Science</a></td>
<td>关于Bioconductor的网络课程，有视频，有材料</td>
</tr>
<tr>
<td><a href="http://userweb.eng.gla.ac.uk/umer.ijaz/bioinformatics/linux.html" target="_blank" rel="external">Linux command line exercises for NGS data processing</a></td>
<td>frequently used tools for NGS analysis as well as giving experience in writing one-liners</td>
</tr>
<tr>
<td><a href="http://wiki.bits.vib.be/index.php/Introduction_to_Linux_for_bioinformatics" target="_blank" rel="external">Introduction to Linux for bioinformatics</a></td>
<td>VIB Bioinformatics Core Wiki</td>
</tr>
</tbody>
</table>
<h1 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://userweb.eng.gla.ac.uk/umer.ijaz/bioinformatics/Illumina_workflow.html" target="_blank" rel="external">Illumina Amplicons Processing Workflow</a></td>
<td>16S pipelines</td>
</tr>
<tr>
<td><a href="http://www.jianshu.com/p/938d362fc48d" target="_blank" rel="external">bio简书</a></td>
<td>bwa+samtools+picardtools+GATK call SNP 流程</td>
</tr>
</tbody>
</table>
<h1 id="生信数据库"><a href="#生信数据库" class="headerlink" title="生信数据库"></a>生信数据库</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description </th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.snpedia.com" target="_blank" rel="external">SNPedia</a></td>
<td>SNP与人类疾病，人群频率，文献报道</td>
</tr>
<tr>
<td><a href="https://link.zhihu.com/?target=http%3A//www.ebi.ac.uk/gwas/" target="_blank" rel="external">GWAS Catalog </a></td>
<td>GWAS研究的SNP,triat,Study等</td>
</tr>
<tr>
<td><a href="https://link.zhihu.com/?target=http%3A//www.mirbase.org/" target="_blank" rel="external">miRBase</a></td>
<td>miRNA “官方”列表。</td>
</tr>
<tr>
<td><a href="http://timetree.org/" target="_blank" rel="external">TimeTree</a></td>
<td>进化树的时间尺度。</td>
</tr>
</tbody>
</table>
<h1 id="文献"><a href="#文献" class="headerlink" title="文献"></a>文献</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://apps.webofknowledge.com/UA_GeneralSearch_input.do?product=UA&amp;SID=Z249gIMNTCPIcZBS93N&amp;search_mode=GeneralSearch" target="_blank" rel="external">Web of Science</a></td>
<td>大型综合性、多学科、核心期刊引文索引数据库</td>
</tr>
<tr>
<td><a href="https://www.ncbi.nlm.nih.gov/pubmed/" target="_blank" rel="external">PubMed</a></td>
<td>免费海量英文文献</td>
</tr>
<tr>
<td><a href="http://www.cnki.net/" target="_blank" rel="external">中国知网</a></td>
<td>中文期刊</td>
</tr>
<tr>
<td><a href="http://sci-hub.cc/" target="_blank" rel="external">SCI-HUB</a></td>
<td>收费文献免费下载</td>
</tr>
<tr>
<td><a href="http://www.howsci.com/" target="_blank" rel="external">科研动力</a></td>
<td>专注EndNote, 关注科研论文写作</td>
</tr>
<tr>
<td><a href="https://www.gcbi.com.cn/gclib/html/index" target="_blank" rel="external">GCBI</a></td>
<td>与PubMed同步并课显示影响因子</td>
</tr>
<tr>
<td><a href="https://pubmedplus.com/#/index" target="_blank" rel="external">pubmedplus</a></td>
<td>文献摘要自动翻译（翻译得比较好）</td>
</tr>
<tr>
<td><a href="http://www.chinapubmed.net/" target="_blank" rel="external">China PubMed</a></td>
<td>英文文献摘要翻译（更新不够快）</td>
</tr>
</tbody>
</table>
<h1 id="在线生信小工具"><a href="#在线生信小工具" class="headerlink" title="在线生信小工具"></a>在线生信小工具</h1><h1 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.cmt.com.cn/" target="_blank" rel="external">医学论坛网</a></td>
<td>医学资讯及文献导读</td>
</tr>
<tr>
<td><a href="http://www.seqanswers.com/" target="_blank" rel="external">seqanswer</a></td>
<td>关于测序的一个论坛</td>
</tr>
<tr>
<td><a href="https://www.plob.org/" target="_blank" rel="external">PLoB</a></td>
<td>Public Library of Bioinformatics (中文博客)</td>
</tr>
<tr>
<td><a href="http://www.rna-seqblog.com/" target="_blank" rel="external">rna-seqblog</a></td>
<td>RNA-seq英文博客</td>
</tr>
<tr>
<td><a href="http://www.biotrainee.com/forum.php" target="_blank" rel="external"> biotrainee</a></td>
<td>生信技能树</td>
</tr>
</tbody>
</table>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description </th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.jove.com/" target="_blank" rel="external">Journal of Visualized Experiments ( JoVE)</a></td>
<td>JoVE是一份展示可视化实验的期刊，是世界上第一个同行评议的科技视频期刊</td>
</tr>
</tbody>
</table>
<h1 id="开发社区"><a href="#开发社区" class="headerlink" title="开发社区"></a>开发社区</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.biostars.org/" target="_blank" rel="external">Biostars</a></td>
<td>专注于生物信息学，计算基因组学和生物数据分析的问答社区</td>
</tr>
<tr>
<td><a href="https://segmentfault.com/" target="_blank" rel="external">Segmentfault</a></td>
<td>一个专注于解决编程问题，提高开发技能的社区</td>
</tr>
<tr>
<td><a href="https://stackoverflow.com/" target="_blank" rel="external">Stackoverflow</a></td>
<td>编程相关的IT技术问答网站</td>
</tr>
<tr>
<td><a href="https://github.com/" target="_blank" rel="external">GitHub</a></td>
<td>面向开源及私有软件项目的git托管平台</td>
</tr>
</tbody>
</table>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://man.linuxde.net/" target="_blank" rel="external">Linux命令大全</a></td>
<td>linux命令搜索，查看帮助</td>
</tr>
</tbody>
</table>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://pymotw.com/2/py-modindex.html" target="_blank" rel="external">PYMOTW</a></td>
<td>Python2标准库的使用</td>
</tr>
<tr>
<td><a href="https://github.com/jorvis/biocode" target="_blank" rel="external">Bioinformatics code libraries and scripts</a></td>
<td>常遇到的问题都有脚本（py/pl）</td>
</tr>
</tbody>
</table>
<h1 id="在线小工具"><a href="#在线小工具" class="headerlink" title="在线小工具"></a>在线小工具</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://tool.oschina.net/" target="_blank" rel="external">在线工具</a></td>
<td>开源中国开发的，主要面向码农</td>
</tr>
<tr>
<td><a href="https://smallpdf.com/" target="_blank" rel="external">smallpdf</a></td>
<td>pdf转word等，在线工具</td>
</tr>
<tr>
<td><a href="http://tool.oschina.net/regex/" target="_blank" rel="external">正则表达式在线测试</a></td>
<td>检查脚本中使用的正则表达式是否正确，提前发现问题</td>
</tr>
<tr>
<td><a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="external">RGB颜色对照表</a></td>
<td>绘图配色必备</td>
</tr>
<tr>
<td><a href="http://tool.oschina.net/highlight" target="_blank" rel="external">在线代码着色</a></td>
<td>看看就好</td>
</tr>
<tr>
<td><a href="http://tool.oschina.net/markdown" target="_blank" rel="external">在线 Markdown 编译器</a></td>
<td>用着不错</td>
</tr>
<tr>
<td><a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="external">ASCII码对照表</a></td>
<td>速查</td>
</tr>
<tr>
<td><a href="http://tool.oschina.net/qr" target="_blank" rel="external">在线生成二维码</a></td>
<td>比较好玩儿</td>
</tr>
</tbody>
</table>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.pdfdrive.net/" target="_blank" rel="external">PDFDRIVE</a></td>
<td>搜索下载免费的pdf电子书</td>
</tr>
</tbody>
</table>
<h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.bingdian001.com/?p=30" target="_blank" rel="external">冰点文库下载器</a></td>
<td>自由下载百度、豆丁、丁香、MBALib、道客巴巴、Book118等文库文档</td>
</tr>
<tr>
<td><a href="http://www.3322.cc/soft/201509041764.html" target="_blank" rel="external">visio</a></td>
<td>专业绘制流程图</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;常用链接（持续更新）&lt;/blockquote&gt;
    
    </summary>
    
      <category term="常用链接" scheme="https:///AnJingwd.github.io/categories/%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5/"/>
    
    
      <category term="常用链接" scheme="https:///AnJingwd.github.io/tags/%E5%B8%B8%E7%94%A8%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>bedtools使用教程详解</title>
    <link href="https:///AnJingwd.github.io/2017/08/19/bedtools%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https:///AnJingwd.github.io/2017/08/19/bedtools使用教程详解/</id>
    <published>2017-08-19T06:40:56.000Z</published>
    <updated>2017-08-19T06:44:00.546Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;bedtools开发的目的是为了快速，灵活的比较大量的基因组特征（genomic features）。而genomic features通常使用Browser Extensible Data (BED) 或者 General Feature Format (GFF)文件表示，用UCSC Genome Browser进行可视化比较。</p>
<p>&emsp;&emsp;例如,bedtools可以进行取intersect（交集）, merge（并集）, count（计数）, complement（补集），以及用来对广泛使用的基因组文件格式，例如BAM, BED, GFF/GTF, VCF等进行基因组区间的转换。单个的工具设计的目的是应对简单的任务，复杂的分析能通过组合多个bedtools工具操作实现。同时，该工具允许控制输出结果的呈现形式。最初的bedtools版本支持单独的6列BED文件。但是，如今增加了对序列比对BAM文件的支持。以及GFF文件的特征，BED文件。以及VCF文件。这些工具是相当快速的，并且即使是大的数据集也可以在数秒内完成任务。</p>
<a id="more"></a>
<h1 id="我们用bedtools都可以做些啥"><a href="#我们用bedtools都可以做些啥" class="headerlink" title="我们用bedtools都可以做些啥?"></a>我们用bedtools都可以做些啥?</h1><p>&emsp;&emsp;bedtools总共有二三十个工具/命令来处理基因组数据。比较典型而且常用的功能举例如下：格式转换，bam转bed（bamToBed），bed转其他格式（bedToBam，bedToIgv）；对基因组坐标的逻辑运算，包括：交集（intersectBed，windowBed），”邻集“（closestBed），补集（complementBed），并集（mergeBed），差集（subtractBed）;计算覆盖度（coverage）（coverageBed，genomeCoverageBed）；<br>此外，还有一些强大而实用的工具（shuffleBed，groupBy，annotateBed，……）</p>
<table>
<thead>
<tr>
<th>Utility</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>annotate</td>
<td>Annotate coverage of features from multiple files.</td>
</tr>
<tr>
<td>bamtobed</td>
<td>Convert BAM alignments to BED (&amp; other) formats.</td>
</tr>
<tr>
<td>bamtofastq</td>
<td>Convert BAM records to FASTQ records.</td>
</tr>
<tr>
<td>bed12tobed6</td>
<td>Breaks BED12 intervals into discrete BED6 intervals.</td>
</tr>
<tr>
<td>bedpetobam</td>
<td>Convert BEDPE intervals to BAM records.</td>
</tr>
<tr>
<td>bedtobam</td>
<td>Convert intervals to BAM records.</td>
</tr>
<tr>
<td>closest</td>
<td>Find the closest, potentially non-overlapping interval.</td>
</tr>
<tr>
<td>cluster</td>
<td>Cluster (but don’t merge) overlapping/nearby intervals.</td>
</tr>
<tr>
<td>complement</td>
<td>Extract intervals <em>not</em> represented by an interval file.</td>
</tr>
<tr>
<td>coverage</td>
<td>Compute the coverage over defined intervals.</td>
</tr>
<tr>
<td>expand</td>
<td>Replicate lines based on lists of values in columns.</td>
</tr>
<tr>
<td>flank</td>
<td>Create new intervals from the flanks of existing intervals.</td>
</tr>
<tr>
<td>genomecov</td>
<td>Compute the coverage over an entire genome.</td>
</tr>
<tr>
<td>getfasta</td>
<td>Use intervals to extract sequences from a FASTA file.</td>
</tr>
<tr>
<td>groupby</td>
<td>Group by common cols. &amp; summarize oth. cols. (~ SQL “groupBy”)</td>
</tr>
<tr>
<td>igv</td>
<td>Create an IGV snapshot batch script.</td>
</tr>
<tr>
<td>intersect</td>
<td>Find overlapping intervals in various ways.</td>
</tr>
<tr>
<td>jaccard</td>
<td>Calculate the Jaccard statistic b/w two sets of intervals.</td>
</tr>
<tr>
<td>links</td>
<td>Create a HTML page of links to UCSC locations.</td>
</tr>
<tr>
<td>makewindows</td>
<td>Make interval “windows” across a genome.</td>
</tr>
<tr>
<td>map</td>
<td>Apply a function to a column for each overlapping interval.</td>
</tr>
<tr>
<td>maskfasta</td>
<td>Use intervals to mask sequences from a FASTA file.</td>
</tr>
<tr>
<td>merge</td>
<td>Combine overlapping/nearby intervals into a single interval.</td>
</tr>
<tr>
<td>multicov</td>
<td>Counts coverage from multiple BAMs at specific intervals.</td>
</tr>
<tr>
<td>multiinter</td>
<td>Identifies common intervals among multiple interval files.</td>
</tr>
<tr>
<td>nuc</td>
<td>Profile the nucleotide content of intervals in a FASTA file.</td>
</tr>
<tr>
<td>overlap</td>
<td>Computes the amount of overlap from two intervals.</td>
</tr>
<tr>
<td>pairtobed</td>
<td>Find pairs that overlap intervals in various ways.</td>
</tr>
<tr>
<td>pairtopair</td>
<td>Find pairs that overlap other pairs in various ways.</td>
</tr>
<tr>
<td>random</td>
<td>Generate random intervals in a genome.</td>
</tr>
<tr>
<td>reldist</td>
<td>Calculate the distribution of relative distances b/w two files.</td>
</tr>
<tr>
<td>shift</td>
<td>Adjust the position of intervals.</td>
</tr>
<tr>
<td>shuffle</td>
<td>Randomly redistribute intervals in a genome.</td>
</tr>
<tr>
<td>slop</td>
<td>Adjust the size of intervals.</td>
</tr>
<tr>
<td>sort</td>
<td>Order the intervals in a file.</td>
</tr>
<tr>
<td>subtract</td>
<td>Remove intervals based on overlaps b/w two files.</td>
</tr>
<tr>
<td>tag</td>
<td>Tag BAM alignments based on overlaps with interval files.</td>
</tr>
<tr>
<td>unionbedg</td>
<td>Combines coverage intervals from multiple BEDGRAPH files.</td>
</tr>
<tr>
<td>window</td>
<td>Find overlapping intervals within a window around an interval.</td>
</tr>
</tbody>
</table>
<h1 id="BEDTools-suite使用详细"><a href="#BEDTools-suite使用详细" class="headerlink" title="BEDTools suite使用详细"></a>BEDTools suite使用详细</h1><p>bedtools官网：</p>
<p><a href="http://bedtools.readthedocs.io/en/latest/" target="_blank" rel="external">http://bedtools.readthedocs.io/en/latest/</a></p>
<p>bedtools使用说明：</p>
<p><a href="http://quinlanlab.org/tutorials/bedtools/bedtools.html#bedtools-merge" target="_blank" rel="external">http://quinlanlab.org/tutorials/bedtools/bedtools.html#bedtools-merge</a></p>
<p>BEDTools主要使用BED格式的前三列,即：</p>
<ul>
<li>chrom: 染色体信息</li>
<li>start: genome feature的起始位点，从0开始</li>
<li>end: genome feature的终止位点，至少为1</li>
</ul>
<p>一般常用物种的genome file在BEDTools安装目录的/genome里面</p>
<p>BEDPE格式是其自定义的一种新的格式，为了简洁的描述不连续的genome features，例如结构变异和双端测序比对</p>
<p><img src="http://i.imgur.com/IkrWjCV.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>start1和start2起始坐标第一个碱基都为0，所以start=9, end=20表示碱基跨度是从第10位到第20位</li>
<li>chrom1或者chrom2用.表示unknown;start1，end1,start2,end2用-1表示unknown</li>
</ul>
<h2 id="1-intersect"><a href="#1-intersect" class="headerlink" title="(1)intersect"></a>(1)intersect</h2><p>&emsp;&emsp;可以计算两个或者多个BED/BAM/VCF/GFF文件中基因组坐标位置的交集(overlap)，根据参数不同，可以得到不同的结果。</p>
<h3 id="两个BED文件比较图示"><a href="#两个BED文件比较图示" class="headerlink" title="两个BED文件比较图示"></a>两个BED文件比较图示</h3><p><img src="http://i.imgur.com/Ufi6ll1.jpg" alt=""></p>
<h3 id="一对多比较图示"><a href="#一对多比较图示" class="headerlink" title="一对多比较图示"></a>一对多比较图示</h3><p><img src="http://i.imgur.com/6RXlcnP.jpg" alt=""></p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><pre><code>bedtools intersect  -a &lt;bed/gff/vcf/bam&gt; -b &lt;bed/gff/vcf/bam&gt; [OPTIONS]
</code></pre><ul>
<li>-wa参数可以报告出原始的在A文件中的feature</li>
<li>-wb参数可以报告出原始的在B文件中的feature</li>
<li>-c参数可以报告出两个文件中的overlap的feature的数量</li>
<li>-wo 返回overlap碱基数</li>
<li>-v 返回非overlap区间</li>
<li>-s 相同链上的feature</li>
</ul>
<p><strong>当用bedtools intersect 处理大文件时比较耗内存，有效的方法是对A和B文件按照染色体名字(chromosome)和位置(position)排序(sort -k1,1 -k2,2n),然后用-sorted参数重新intersect</strong></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p><strong>注意，自己生成测试bed文件，都必须用tab键分割，否则会报错！！</strong></p>
<ol>
<li><p>案例一：包含着染色体位置的两个文件，分别记为A文件和B文件。分别来自于不同文件的染色体位置的交集是什么？</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed </p>
<p> chr1 15 20 </p>
</li>
<li><p>案例二：包含着染色体位置的两个文件，分别记为A文件和B文件。求A文件中哪些染色体位置是与文件B中的染色体位置有overlap.</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed -wa</p>
<p> chr1 10 20 </p>
</li>
<li><p>案例三：包含着染色体位置的两个文件，分别记为A文件和B文件。求A文件中染色体位置与文件B中染色体位置的交集，以及对应的文件B中的染色体位置.</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed -wb</p>
<p> chr1 15 20 chr1 15 25</p>
</li>
<li><p>案例四（经用）： 包含着染色体位置的两个文件，分别记为A文件和B文件。求对于A文件的染色体位置是否与文件B中的染色体位置有交集。如果有交集，分别输入A文件的染色体位置和B文件的染色体位置；如果没有交集，输入A文件的染色体位置并以’. -1 -1’补齐文件。</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed -loj</p>
<p> chr1 10 20 chr1 15 25</p>
<p> chr1 30 40 . -1 -1</p>
</li>
<li><p>案例五：  包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，如果和B文件中染色体位置有overlap,则输出在A文件中染色体位置和在B文件中染色体位置，以及overlap的长度.</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 20</p>
<p> chr1 18 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed -wo</p>
<p> chr1 10 20 chr1 15 20 5</p>
<p> chr1 10 20 chr1 18 25 2 </p>
</li>
<li><p>案例六：  包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，如果和B文件中染色体位置有overlap,则输出在A文件中染色体位置和在B文件中染色体位置，以及overlap的长度；如果和B文件中染色体位置都没有overlap,则用’. -1-1’补齐文件</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 20</p>
<p> chr1 18 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed -wao</p>
<p> chr1 10 20 chr1 15 20 5</p>
<p> chr1 10 20 chr1 18 25 2 </p>
<p> chr1 30 40 . -1 -1</p>
</li>
<li><p>案例七：  包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，输出在A文件中染色体位置和有多少B文件染色体位置与之有overlap.</p>
<p> $ cat A.bed</p>
<p> chr1 10 20</p>
<p> chr1 30 40</p>
<p> $ cat B.bed</p>
<p> chr1 15 20</p>
<p> chr1 18 25</p>
<p> $ bedtools intersect -a A.bed -b B.bed -c</p>
<p> chr1 10 20 2</p>
<p> chr1 30 40 0 </p>
</li>
<li><p>案例八(常用)：  包含着染色体位置的两个文件，分别记为A文件和B文件。对于A文件中染色体位置，输出在A文件中染色体位置和与B文件染色体位置至少有X%的overlap的记录。</p>
<p> $ cat A.bed</p>
<p> chr1 100 200</p>
<p> $ cat B.bed</p>
<p> chr1 130 201</p>
<p> chr1 180 220</p>
<p> $ bedtools intersect -a A.bed -b B.bed -f 0.50 -wa -wb  </p>
<p> chr1 100 200 chr1 130 201 </p>
</li>
</ol>
<h2 id="2-merge"><a href="#2-merge" class="headerlink" title="(2)merge"></a>(2)merge</h2><p>&emsp;&emsp;用于合并位于同一个bed/gff/vcf 文件中有overlap或者距离在一定范围内的相邻区间，距离可由参数(-d)定义。需要注意的是，做合并之前需要先对bed文件做根据染色体排序，可以用bedtoolssort命令实现。</p>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="http://i.imgur.com/CLbhHg9.jpg" alt=""></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>bedtools merge [OPTIONS] -i &lt;bed/gff/vcf&gt;
</code></pre><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><pre><code>$ cat A.bed

chr2 10 20

chr1 30 40

chr1 15 20

chr1 18 25
</code></pre><p>排序：</p>
<pre><code>sort -k1,1 -k2,2n A.bed &gt; A.sort.bed

$ cat A.sort.bed 

chr1 15 20

chr1 18 25

chr1 30 40

chr2 10 20
</code></pre><ol>
<li><p>案例一：取并集</p>
<p> bedtools merge -i A.sort.bed</p>
<p> chr1    15    25</p>
<p> chr1    30    40</p>
<p> chr2    10    20</p>
</li>
<li><p>案例二：计算重叠区间的个数,-i 指定统计的列，-o指定操作5</p>
<p> bedtools merge -i exons.bed -c 1 -o count</p>
<p> chr1    15    25    2</p>
<p> chr1    30    40    1</p>
<p> chr2    10    20    1</p>
</li>
<li><p>案例三：-d 两个独立区域间距小于（等于）该值时将被合并为一个区域；-o collapse显示合并了哪些标签</p>
<p> $ bedtools merge -i A.sort.bed -d 5 -c 1 -o count，collapse</p>
<p> chr1    15    40    3    chr1,chr1,chr1</p>
<p> chr2    10    20    1    chr2</p>
</li>
</ol>
<h2 id="3-complement：返回基因组非覆盖区（用途，比如多轮设计panel"><a href="#3-complement：返回基因组非覆盖区（用途，比如多轮设计panel" class="headerlink" title="(3)complement：返回基因组非覆盖区（用途，比如多轮设计panel)"></a>(3)complement：返回基因组非覆盖区（用途，比如多轮设计panel)</h2><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p><img src="http://i.imgur.com/k26Ar7F.jpg" alt=""></p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>bedtools complement -i &lt;BED/GFF/VCF&gt; -g &lt;genome files&gt;
</code></pre><h2 id="4-genomecov：染色体和全基因组覆盖度计算"><a href="#4-genomecov：染色体和全基因组覆盖度计算" class="headerlink" title="(4)genomecov：染色体和全基因组覆盖度计算"></a>(4)genomecov：染色体和全基因组覆盖度计算</h2><p>要求：单个输入bed文件（-i指定）和genome files；如果输入为bam(-ibam指定)文件，则不需要genome files</p>
<h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p><img src="http://i.imgur.com/5kHXyrU.jpg" alt=""></p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre><code>bedtools genomecov [OPTIONS] -i &lt;bed/gff/vcf&gt; -g &lt;genome&gt;
</code></pre><h3 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h3><pre><code>$ cat ranges-cov-sorted.bed
chr1    4       9
chr1    1       6
chr1    8       19
chr1    25      30
chr2    0       20

$ cat cov.txt  （染色体及每条染色体总碱基数）
chr1    30
chr2    20

bedtools genomecov -i ranges-cov-sorted.bed -g cov.txt
chr1    0       7       30      0.233333 1
chr1    1       20      30      0.666667
chr1    2       3       30      0.1
chr2    1       20      20      1 2
genome  0       7       50      0.14 3
genome  1       40      50      0.8
genome  2       3       50      0.06
#name 覆盖次数 覆盖碱基数 总碱基数   覆盖度
#同时计算单染色体和全基因组覆盖度
</code></pre><ul>
<li>ranges-cov.bed文件需提前排序sort -k1,1 ranges-cov.bed &gt; ranges-cov-sorted.bed</li>
<li>-bg参数可得到每个碱基的覆盖度。</li>
</ul>
<h2 id="5-coverage-计算染色体给定区间覆盖度，输入可以是-BAM-文件"><a href="#5-coverage-计算染色体给定区间覆盖度，输入可以是-BAM-文件" class="headerlink" title="(5)coverage 计算染色体给定区间覆盖度，输入可以是 BAM 文件"></a>(5)coverage 计算染色体给定区间覆盖度，输入可以是 BAM 文件</h2><pre><code>$ cat A.bed
chr1  0   100
chr1  100 200
chr2  0   100

$ cat B.bed
chr1  10  20
chr1  20  30
chr1  30  40
chr1  100 200

$ bedtools coverage -a A.bed -b B.bed
chr1  0   100  3  30  100 0.3000000
chr1  100 200  1  100 100 1.0000000
chr2  0   100  0  0   100 0.0000000
#name 覆盖次数 覆盖碱基数 总碱基数   覆盖度
</code></pre><h2 id="6-getfasta：提取序列"><a href="#6-getfasta：提取序列" class="headerlink" title="(6)getfasta：提取序列"></a>(6)getfasta：提取序列</h2><p>提取指定位置的 DNA 序列，也是很好用的一个功能，反向互补链也可以提，不用自己写脚本提了</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre><code>bedtools getfasta [OPTIONS] -fi &lt;fasta&gt; -bed &lt;bed/gff/vcf&gt; -fo &lt;fasta&gt; 
</code></pre><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><p>要求：基因组fasta文件（-fi指定）,提取区间BED/GTF/GFF/VCF文件(-bed指定),输出文件FASTA（-fo 指定）</p>
<pre><code>bedtools getfasta -fi Mus_musculus.GRCm38.75.dna_rm.toplevel_chr1.fa -bed mm_GRCm38_3kb_promoters.gtf -fo mm_GRCm38_3kb_promoters.fasta
</code></pre><p>扩展：</p>
<p>提取序列之samtools（速度较快）</p>
<pre><code>#首先建立fai索引文件（第一列为染色体名字，第二列为序列碱基数）

samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa

#序列提取，多提取区间空格隔开

samtools faidx Mus_musculus.GRCm38.75.dna.chromosome.8.fa \
 8:123407082-123410744 8:123518835-123536649

&gt;8:123407082-123410744
GAGAAAAGCTCCCTTCTTCTCCAGAGTCCCGTCTACCCTGGCTTGGCGAGGGAAAGGAAC
CAGACATATATCAGAGGCAAGTAACCAAGAAGTCTGGAGGTGTTGAGTTTAGGCATGTCT
[...]

&gt;8:123518835-123536649
TCTCGCGAGGATTTGAGAACCAGCACGGGATCTAGTCGGAGTTGCCAGGAGACCGCGCAG
CCTCCTCTGACCAGCGCCCATCCCGGATTAGTGGAAGTGCTGGACTGCTGGCACCATGGT
[...]
</code></pre><h2 id="7-nuc-计算GC含量即各碱基数"><a href="#7-nuc-计算GC含量即各碱基数" class="headerlink" title="(7)nuc: 计算GC含量即各碱基数"></a>(7)nuc: 计算GC含量即各碱基数</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><pre><code>bedtools nuc [OPTIONS] -fi &lt;fasta&gt; -bed &lt;bed/gff/vcf&gt;
</code></pre><p>Options: </p>
<pre><code>-fi     输入FASTA文件

-bed     提取区间BED/GTF/GFF/VCF文件(-bed指定)
</code></pre><h3 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h3><pre><code>bedtools nuc -fi hg19.fa -bed CDS.bed
</code></pre><p>输出结果解释：在原bed文件每行结尾增加以下几列</p>
<p>Output format:<br>The following information will be reported after each BED entry:</p>
<pre><code>1) %AT content
2) %GC content
3) Number of As observed
4) Number of Cs observed
5) Number of Gs observed
6) Number of Ts observed
7) Number of Ns observed
8) Number of other bases observed
9) The length of the explored sequence/interval.
10) The seq. extracted from the FASTA file. (opt., if -seq is used)
11) The number of times a user&apos;s pattern was observed.
    (opt., if -pattern is used.)
</code></pre><h1 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h1><p><a href="http://gettinggeneticsdone.blogspot.com/2014/03/visualize-coverage-exome-targeted-ngs-bedtools.html" target="_blank" rel="external">Coverage analysis for targeted DNA capture</a></p>
<p><a href="http://www.cureffi.org/2013/11/18/an-mrna-seq-pipeline-using-gsnap-samtools-cufflinks-and-bedtools/" target="_blank" rel="external">RNA-seq coverage analysis</a></p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>（1）王球爸的博客：</p>
<p><a href="http://blog.sina.com.cn/s/blog_5d5f892a0102v665.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_5d5f892a0102v665.html</a></p>
<p>（2）生信人</p>
<p><a href="https://www.wxzhi.com/archives/871/gk4yd3ujan57e0ft/" target="_blank" rel="external">https://www.wxzhi.com/archives/871/gk4yd3ujan57e0ft/</a></p>
<p>（3）hope</p>
<p><a href="http://tiramisutes.github.io/2016/03/18/bedtools.html" target="_blank" rel="external">http://tiramisutes.github.io/2016/03/18/bedtools.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;bedtools开发的目的是为了快速，灵活的比较大量的基因组特征（genomic features）。而genomic features通常使用Browser Extensible Data (BED) 或者 General Feature Format (GFF)文件表示，用UCSC Genome Browser进行可视化比较。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;例如,bedtools可以进行取intersect（交集）, merge（并集）, count（计数）, complement（补集），以及用来对广泛使用的基因组文件格式，例如BAM, BED, GFF/GTF, VCF等进行基因组区间的转换。单个的工具设计的目的是应对简单的任务，复杂的分析能通过组合多个bedtools工具操作实现。同时，该工具允许控制输出结果的呈现形式。最初的bedtools版本支持单独的6列BED文件。但是，如今增加了对序列比对BAM文件的支持。以及GFF文件的特征，BED文件。以及VCF文件。这些工具是相当快速的，并且即使是大的数据集也可以在数秒内完成任务。&lt;/p&gt;
    
    </summary>
    
      <category term="NGS软件" scheme="https:///AnJingwd.github.io/categories/NGS%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="NGS软件" scheme="https:///AnJingwd.github.io/tags/NGS%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>linux解压缩</title>
    <link href="https:///AnJingwd.github.io/2017/08/16/linux%E8%A7%A3%E5%8E%8B%E7%BC%A9/"/>
    <id>https:///AnJingwd.github.io/2017/08/16/linux解压缩/</id>
    <published>2017-08-16T02:48:41.000Z</published>
    <updated>2017-08-16T08:07:13.065Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">总结下linux下各种压缩文件的解压方法及批量解压</blockquote>

<a id="more"></a>
<p>首先要弄清两个概念：打包 和 压缩：</p>
<ul>
<li>打包 是指将一大堆文件或目录变成一个总的文件； </li>
<li>压缩 则是将一个大的文件通过一些压缩算法变成一个小文件。</li>
</ul>
<p>&emsp;&emsp;Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p>
<h1 id="单个解压"><a href="#单个解压" class="headerlink" title="单个解压"></a>单个解压</h1><ol>
<li>*.tar 用 tar -xvf 解压</li>
<li>*.gz 用 gzip -d或者gunzip 解压</li>
<li><em>.tar.gz和</em>.tgz 用 tar -xzf 解压</li>
<li>*.bz2 用 bzip2 -d或者用bunzip2 解压</li>
<li>*.tar.bz2用tar -xjf 解压</li>
<li>*.Z 用 uncompress 解压</li>
<li>*.tar.Z 用tar -xZf 解压</li>
<li>*.rar 用 unrar e解压</li>
<li>*.zip 用 unzip 解压</li>
<li><p>*.tar.xz 用</p>
<p>$xz -d <em>*</em>.tar.xz</p>
<p>$tar -xvf  <em>*</em>.tar</p>
</li>
</ol>
<h1 id="批量解压"><a href="#批量解压" class="headerlink" title="批量解压"></a>批量解压</h1><ol>
<li><p>方法一：</p>
<p>  for i in $(ls *.tar.gz);do tar xvf $i;done</p>
</li>
</ol>
<ol>
<li><p>方法二:</p>
<p> for tarfile in *.tar.gz;  do tar -xvf $tarfile; done</p>
</li>
<li><p>方法三:</p>
<p>  ls *.tar.gz|xargs -n1 tar xzvf</p>
</li>
</ol>
<p>&emsp;&emsp;xargs 是一条 Unix 和类 Unix 操作系统的常用命令；它的作用是将参数列表转换成小块分段传递给其他命令，以避免参数列表过长的问题。</p>
<p>例如：</p>
<p>echo “1 2 3 4”|xargs -n1<br>1<br>2<br>3<br>4<br>echo “1 2 3 4”|xargs -n2<br>1 2<br>3 4</p>
<p>所以，加n1参数，则*.tar.gz会拆成每个tar.gz文件后，一个一个传给tar xzvf命令</p>
<ol>
<li><p>方法四：</p>
<p> find -maxdepth 1 -name “*.tar.gz”|xargs -i tar xvzf {}</p>
</li>
</ol>
<p>&emsp;&emsp;这条命令可解压当前目录下的所有gz文件，maxdepth表示搜索深度，1代表只搜索当前目录</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>使用tar -xvf *.tar.gz会出错，提示“Not found in archive”？</p>
<p>通配符是shell解决的问题,如</p>
<blockquote>
<p>tar -xvf *.tar.gz</p>
</blockquote>
<p>实际上执行tar时，tar接收到的是</p>
<blockquote>
<p>tar -xvf a.tar.gz  b.tar.gz  c.tar.gz …</p>
</blockquote>
<p>如果当前目录跟本没有tar的东西，那么tar就收到’*.tar.gz’这个参数</p>
<p>与win不同，linux所有字符都可以作文件名，也即目录中不存在着 *.tar.gz这个文件</p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>同样可以利用for循环遍历操作某一类文件，比如批量建索引。</p>
<pre><code>for i in `ls`
do
        samtools faidx $i
done
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;总结下linux下各种压缩文件的解压方法及批量解压&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="https:///AnJingwd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https:///AnJingwd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>NGS数据格式BED/GFF/GTF之介绍，比较，转换</title>
    <link href="https:///AnJingwd.github.io/2017/08/15/NGS%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8FBED-GFF-GTF%E4%B9%8B%E4%BB%8B%E7%BB%8D-%E6%AF%94%E8%BE%83-%E8%BD%AC%E6%8D%A2/"/>
    <id>https:///AnJingwd.github.io/2017/08/15/NGS数据格式BED-GFF-GTF之介绍-比较-转换/</id>
    <published>2017-08-15T11:09:02.000Z</published>
    <updated>2017-08-15T11:09:28.033Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;NGS数据格式BED/GFF/GTF之介绍，比较，转换</p>
<a id="more"></a>
<h1 id="Ensemble与UCSC各种格式说明"><a href="#Ensemble与UCSC各种格式说明" class="headerlink" title="Ensemble与UCSC各种格式说明"></a>Ensemble与UCSC各种格式说明</h1><p>Ensemble各种格式说明：</p>
<p><a href="http://www.ensembl.org/info/website/upload/bed.html" target="_blank" rel="external">http://www.ensembl.org/info/website/upload/bed.html</a></p>
<p>UCSC各种格式说明：</p>
<p><a href="http://genome.ucsc.edu/FAQ/FAQformat.html#format1" target="_blank" rel="external">http://genome.ucsc.edu/FAQ/FAQformat.html#format1</a></p>
<hr>
<h1 id="基因组坐标系统"><a href="#基因组坐标系统" class="headerlink" title="基因组坐标系统"></a>基因组坐标系统</h1><p>&emsp;&emsp;计算机和现实世界有一个差别，即计算机的计数是从0开始的（即0-based），而现实生活中，我们的计数是从1开始的（即1-based）。在生物学领域的不同场合，这两种计数交杂出现</p>
<p>两套不同理念的坐标系统——base coordinate system(BCS)和interbase coordinate system（ICS）</p>
<p><img src="http://i.imgur.com/fDzHOmo.jpg" alt=""></p>
<p>我们先来分析一下这样的两套系统在表述序列位置时的差别</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>1-based</th>
<th>0-based</th>
</tr>
</thead>
<tbody>
<tr>
<td>单个核苷酸</td>
<td>4-4: T</td>
<td>3-4: T</td>
</tr>
<tr>
<td>一组核苷酸</td>
<td>4-6: TAA</td>
<td>3-6: TAA</td>
</tr>
<tr>
<td>deletion</td>
<td>4-4: T/-</td>
<td>3-4: T/-</td>
</tr>
<tr>
<td>insertion（表示AGGTCGAAGT）</td>
<td>4-5: -/CG</td>
<td>4-4: -/CG</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;如果说我们不管0-based和1-based这两种计数方式对应的坐标系统，都将其视为对序列第一个核苷酸的描述（即第一个核苷酸是算0还是算1），那么0-based的系统，其区间其实是一个左闭右开的区间，而1-based的系统则是一个闭区间。</p>
<p><img src="http://i.imgur.com/zNrQ5gc.jpg" alt=""></p>
<p>1-based，正如前述，就是为了符合人的计数习惯。那UCSC为什么要采用0-based的interbase coordinate system系统？ICS主要的好处体现在下面的几个方面：</p>
<ul>
<li>对于splicing sites等涉及两个核苷酸之间位置的情况，ICS提供了一个更好的呈现方案；</li>
<li>对于site的计算更加方便，如length=end-start;</li>
<li>对于坐标的转换，尤其是正负链坐标间的转换更加方便。（revStart = chromSize – oneEnd，revEnd = chromeSize – zeroStart）。</li>
</ul>
<p>NCBI等组织采用的是和人日常习惯一致的1-based计数系统，即用数字指代核苷酸位置。但是UCSC发现使用0-based计数系统（用数字指代核苷酸间的位置）</p>
<p>&emsp;&emsp;应用范畴：对于直接给所有用户提供直观访问服务的data portal（比如说NCBI、Ensembl、UCSC Genome Browser、mirBase）、常用的生物信息学软件（如BLAST）以及某些格式的文件（如GFF、SAM、VCF），采用的是1-based的计数方法。与之相反，UCSC的Table Browser以及它在数据库中存储的数据、BED/BAM等格式的文件，以及Chado、DAS2、dbSNP这样的data portal则采用的是0-based的计数方法。</p>
<h1 id="单个格式介绍"><a href="#单个格式介绍" class="headerlink" title="单个格式介绍"></a>单个格式介绍</h1><h2 id="BED格式"><a href="#BED格式" class="headerlink" title="BED格式"></a>BED格式</h2><p><img src="http://i.imgur.com/ImVRGpB.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>chromStart起始坐标第一个碱基为0</li>
<li>BED行名会展示在基因组浏览器中的bed行的左侧</li>
</ul>
<p>UCSC中展示效果：</p>
<p><img src="http://i.imgur.com/1tweu6f.png" alt=""></p>
<hr>
<p><strong>其实，你可以通过UCSC Genome Browser展示你的注释 tracks数据,并以可视化的方式与其他注释数据进行比较！！！</strong></p>
<p>UCSC官方说明—-Displaying Your Own Annotations in the Genome Browser：</p>
<p><a href="http://genome.ucsc.edu/goldenPath/help/customTrack.html#EXAMPLE1" target="_blank" rel="external">http://genome.ucsc.edu/goldenPath/help/customTrack.html#EXAMPLE1</a></p>
<h3 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h3><p>&emsp;&emsp;个人的注释数据再上传48小时后将失效，除非你登陆并创建会话。</p>
<p>如何登陆Genome Browser并创建会话：</p>
<p><a href="http://genome.ucsc.edu/goldenPath/help/hgSessionHelp.html#CTs" target="_blank" rel="external">http://genome.ucsc.edu/goldenPath/help/hgSessionHelp.html#CTs</a></p>
<p>当然，你也可以查看别人的定制注释tracks数据：</p>
<p><a href="http://genome.ucsc.edu/goldenPath/customTracks/custTracks.html" target="_blank" rel="external">http://genome.ucsc.edu/goldenPath/customTracks/custTracks.html</a></p>
<p>Genome Browser annotation tracks是基于面向行格式的文件的，文件中每行展示一个track特征，注释文件包含三种类型的行：browser lines, track lines, and data lines。空行和其他以#开头的行将被忽略。</p>
<ol>
<li>如何构建注释文件呢？</li>
</ol>
<ul>
<li>（1）数据格式</li>
</ul>
<p>目前支持标准的GFF格式，以及为Human Genome Project 和 UCSC Genome Browser定制的数据格式，常见的如BED,BAM,VCF,MAF等。注意GFF和GTF文件必须以tab键分割，而不是以空格分隔。参考染色体必须以chrN的形式（区分大小写）。</p>
<ul>
<li>（2）定义 Genome Browser展示特征的区间</li>
</ul>
<p>例如：browser position chr22:20100000-20100900</p>
<p>没有的话，展示的tracks在基因组的位置可能不对</p>
<ul>
<li>（3）定义注释track的一些属性</li>
</ul>
<p>例如track的name, description, colors, initial display mode, use score等等</p>
<ol>
<li>如何展示呢？</li>
</ol>
<p>例如注释数据如下：</p>
<p>browser position chr22:1000-10000<br>browser hide all<br>track name=”BED track” description=”BED format custom track example” visibility=2 color=0,128,0 useScore=1<br>chr22 1000 5000 itemA 960 + 1100 4700 0 2 1567,1488, 0,2512<br>chr22 2000 7000 itemB 200 - 2200 6950 0 4 433,100,550,1500 0,500,2000,3500</p>
<p>网址：</p>
<p><a href="http://genome.ucsc.edu/cgi-bin/hgCustom" target="_blank" rel="external">http://genome.ucsc.edu/cgi-bin/hgCustom</a></p>
<p><img src="http://i.imgur.com/31EJFSz.jpg" alt=""></p>
<p><img src="http://i.imgur.com/FCQA4pM.png" alt=""></p>
<p><img src="http://i.imgur.com/V3tPNzp.png" alt=""></p>
<p>&emsp;&emsp;当然，可视化展示并不是真正的目的，主要目的是与其他注释数据进行比较，从而发现某些科学问题。最上面是你的track(Custom Tracks),下面就是按照不同数据类型划分的注释数据，默认都是隐藏的（hide），你可以勾选相应你感兴趣的数据，选择（hide,dense,squish,pack,full）不同展现形式显示其他注释数据，然后refresh，进行可视化比较。</p>
<hr>
<h2 id="GFF格式"><a href="#GFF格式" class="headerlink" title="GFF格式"></a>GFF格式</h2><p>参考：</p>
<p><a href="http://www.bbioo.com/lifesciences/40-112835-1.html" target="_blank" rel="external">http://www.bbioo.com/lifesciences/40-112835-1.html</a></p>
<p>GFF格式（General Feature Format）是一种简单的以tab键分割的，用于描述基因组特征的格式文件。有GFF1, GFF2，GFF3和GTF2四种版本。</p>
<h3 id="GFF1"><a href="#GFF1" class="headerlink" title="GFF1"></a>GFF1</h3><p><img src="http://i.imgur.com/M5NdmeO.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>start第一个碱基是从1开始计数的</li>
<li>frame：在feature是coding exon时，frame可以取值0-2，表示读码框的第一个碱基；如果不是coding exon,则用.表示</li>
<li>GFF1与其他GFF格式的最大区别在于所有相同的feature的行是聚集在一起的</li>
<li>扩展名为.gff1而不是gff</li>
</ul>
<h3 id="GFF2"><a href="#GFF2" class="headerlink" title="GFF2"></a>GFF2</h3><p><a href="http://gmod.org/wiki/GFF2" target="_blank" rel="external">http://gmod.org/wiki/GFF2</a></p>
<p><img src="http://i.imgur.com/1XNehY5.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>start第一个碱基是从1开始计数的</li>
<li>frame：在feature是coding exon时，frame可以取值0-2，表示读码框的第一个碱基；如果不是coding exon,则用.表示</li>
<li>attribute：用;分隔键值对（tag-value），为每个feature提供额外的信息。同时attribute包含identifiers，可以用于联系各个特征。</li>
<li>扩展名为.gff2而不是gff</li>
</ul>
<p><strong>GFF2格式的不足</strong></p>
<p>&emsp;&emsp;GFF2的一个问题是它只能表现一个层次的嵌套功能。 当处理具有多个交替剪接的转录物的基因时存在问题。 GFF2无法处理基因→转录本→外显子的三级体系。 大多数人给出一系列的转录本，并给出类似的名称来表明它们来自相同的基因。 第二个限制是，虽然GFF2允许您创建两级层次结构，如转录本→外显子，但它没有层次结构方向的任何概念。 所以它不知道外显子是否是转录本的subfeature，反之亦然。 这意味着你必须使用“aggregators”来整理关系。  因此，GFF2格式已被弃用，转而支持GFF3格式。</p>
<p><strong>但是，目前Genome Browser是不支持GFF3的，所有的GFF track都是基于Sanger’s GFF2 specification</strong></p>
<h3 id="GFF3"><a href="#GFF3" class="headerlink" title="GFF3"></a>GFF3</h3><p><a href="http://gmod.org/wiki/GFF3" target="_blank" rel="external">http://gmod.org/wiki/GFF3</a></p>
<p><img src="http://i.imgur.com/bz4xuEw.jpg" alt=""></p>
<p>注意：</p>
<ul>
<li>start第一个碱基是从1开始计数的</li>
<li>phase：在feature是coding exon时，phase可以取值0-2，表示读码框的第一个碱基；如果不是coding exon,则用.表示</li>
<li>attribute：用 “=” 分隔键值对（tag-value），为每个feature提供额外的信息。同时attribute包含identifiers，可以用于联系各个特征。</li>
<li>扩展名为.gff3而不是gff</li>
</ul>
<p><strong>与其他GFF版本格式最大区别在于：</strong></p>
<ul>
<li>第一行表明版本：##gff-version 3</li>
<li>第9列attributes关联了转录本，之前的GFF版本限制于低层次的feature(exon)</li>
<li>key=value具有特殊的含义<ul>
<li>ID - unique idenfifier for this feature.</li>
<li>Parent - idenfier of parent feature.</li>
<li>Name - used as the feature label in the feature map.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="GTF"><a href="#GTF" class="headerlink" title="GTF"></a>GTF</h2><p>GTF是另外一种与GFF2十分相似的数据格式，有时称之为GFF2.5。GTF的前8列与GFF2完全一样，group列（attribute列）被扩展了，每个属性包含了一个 type/value pair，属性以;结束，初次之外，属性之间还有一个空格。</p>
<p>属性列（第9列）：</p>
<ul>
<li>gene_id value - A globally unique identifier for the genomic source of the sequence.</li>
<li>transcript_id value - A globally unique identifier for the predicted transcript.</li>
</ul>
<p>属性列例子(UCSC)：</p>
<pre><code>gene_id &quot;Em:U62317.C22.6.mRNA&quot;; transcript_id &quot;Em:U62317.C22.6.mRNA&quot;; exon_number 1
</code></pre><p>属性列例子(Ensemble)：</p>
<pre><code>gene_id &quot;ENSG00000223972&quot;; transcript_id &quot;ENST00000456328&quot;; gene_name &quot;DDX11L1&quot;; gene_sourc e &quot;havana&quot;; gene_biotype &quot;transcribed_unprocessed_pseudogene&quot;; transcript_name &quot;DDX11L1-002&quot;; transcript_source &quot;havana&quot;;
</code></pre><p>GTF是不被 GMOD支持的，如果使用，可以将其转换为GFF3格式。</p>
<hr>
<h1 id="不同格式比较"><a href="#不同格式比较" class="headerlink" title="不同格式比较"></a>不同格式比较</h1><h2 id="BED和GFF-GTF"><a href="#BED和GFF-GTF" class="headerlink" title="BED和GFF/GTF"></a>BED和GFF/GTF</h2><ol>
<li>BED文件中起始坐标为0，结束坐标至少是1,； GFF中起始坐标是1而结束坐标至少是1</li>
<li>两者都是基因注释文件，gtf的一行表示一个exon，多行表示一个基因。而bed的一行表示一个基因。</li>
</ol>
<h2 id="GTF与GFF区别"><a href="#GTF与GFF区别" class="headerlink" title="GTF与GFF区别"></a>GTF与GFF区别</h2><ol>
<li><p>简单来说：GFF 2 -&gt; GTF -&gt; GFF 3</p>
</li>
<li><p>G的定义不同</p>
</li>
</ol>
<p>GFF全称为general feature format，这种格式主要是用来注释基因组。</p>
<p>GTF全称为gene transfer format，主要是用来对基因进行注释。</p>
<ol>
<li>GTF是在GFF（GFF2）的基础上的一个改良，GTF的前8列信息与GFF是一样的，主要区别在第九列，GTF扩充很多GFF不具备的其他的信息</li>
</ol>
<hr>
<h1 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h1><table>
<thead>
<tr>
<th>file conversion</th>
<th>script</th>
</tr>
</thead>
<tbody>
<tr>
<td>GTF to GFF3</td>
<td><a href="http://song.cvs.sourceforge.net/song/software/scripts/gtf2gff3/" target="_blank" rel="external">gft2gff3</a></td>
</tr>
<tr>
<td>GTF to BED</td>
<td><a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;filename=gtf2Bed.pl&amp;id=62831" target="_blank" rel="external">gtf2Bed.pl</a></td>
</tr>
<tr>
<td>BED to GTF</td>
<td><a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;filename=bedToGtf.sh&amp;id=62832" target="_blank" rel="external">bedToGtf.sh</a></td>
</tr>
</tbody>
</table>
<p>汇总，将各种格式转换为GFF格式的脚本。这些脚本分散在不同的软件包中，可以根据需要下载使用。</p>
<p>bioPerl</p>
<table>
<thead>
<tr>
<th>script</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>search2gff</td>
<td>This script will turn a protein Search report (BLASTP, FASTP, SSEARCH, AXT, WABA) into a GFF File.</td>
</tr>
<tr>
<td>genbank2gff3.pl</td>
<td>Genbank to gbrowse-friendly GFF3</td>
</tr>
<tr>
<td>gff2ps</td>
<td>This script provides GFF to postscript handling.</td>
</tr>
</tbody>
</table>
<p><strong>如果你在win下安装了perl及bioperl直接在文件夹下搜索便可以找到上述脚本，可以直接使用</strong></p>
<p>gbrowse</p>
<table>
<thead>
<tr>
<th>script</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://search.cpan.org/~lds/GBrowse-2.39/bin/bed2gff3.pl" target="_blank" rel="external">ucsc_genes2gff</a></td>
<td>Convert UCSC Genome Browser-format gene files into GFF files suitable for loading into gbrowse</td>
</tr>
<tr>
<td><a href="http://eugenes.org:7072/gmod/genogrid/scripts/" target="_blank" rel="external">blast92gff3.pl</a></td>
<td>BLAST tabular output (-m 9 or 8) conversion to GFF version 3 format,</td>
</tr>
</tbody>
</table>
<p>DAWGPAWS</p>
<table>
<thead>
<tr>
<th>script</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://dawgpaws.sourceforge.net/man/cnv_blast2gff.html" target="_blank" rel="external">cnv_blast2gff.pl</a></td>
<td>This program will translate a blast report for a single query sequence into the GFF format.</td>
</tr>
</tbody>
</table>
<p>Tandy software</p>
<table>
<thead>
<tr>
<th>script</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://eugenes.org/gmod/tandy/" target="_blank" rel="external">gff2aplot</a></td>
<td>a program to visualize the alignment of two genomic sequences together with their annotations. From GFF-format input files it produces PostScript figures for that alignment.</td>
</tr>
<tr>
<td><a href="http://iubio.bio.indiana.edu:7122/gmod/tandy/" target="_blank" rel="external">blat2gff</a></td>
<td>Converts BLAT output files to GFF formatted files</td>
</tr>
</tbody>
</table>
<p><strong>BioWiki中还有一篇，总结更多GFF工具的文章，请参看下面链接：</strong></p>
<p><a href="http://biowiki.org/GffTools" target="_blank" rel="external">http://biowiki.org/GffTools</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>（1）<a href="http://blog.sciencenet.cn/blog-981687-726831.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-981687-726831.html</a></p>
<p>（2）<a href="http://blog.sciencenet.cn/blog-1509670-847310.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-1509670-847310.html</a></p>
<p>（3）<a href="https://www.yaolibio.com/2016/08/15/gene-coordinate-system/" target="_blank" rel="external">https://www.yaolibio.com/2016/08/15/gene-coordinate-system/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;NGS数据格式BED/GFF/GTF之介绍，比较，转换&lt;/p&gt;
    
    </summary>
    
      <category term="NGS" scheme="https:///AnJingwd.github.io/categories/NGS/"/>
    
    
      <category term="NGS" scheme="https:///AnJingwd.github.io/tags/NGS/"/>
    
  </entry>
  
  <entry>
    <title>Linux神器之grep,awk操作gtf文件</title>
    <link href="https:///AnJingwd.github.io/2017/08/14/Linux%E7%A5%9E%E5%99%A8%E4%B9%8Bgrep,awk%E6%93%8D%E4%BD%9Cgtf%E6%96%87%E4%BB%B6/"/>
    <id>https:///AnJingwd.github.io/2017/08/14/Linux神器之grep,awk操作gtf文件/</id>
    <published>2017-08-14T02:21:26.000Z</published>
    <updated>2017-08-14T15:05:39.320Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">Linux神器之grep,awk操作gtf文件</blockquote>

<a id="more"></a>
<h1 id="Linux神器之grep-awk操作gtf文件"><a href="#Linux神器之grep-awk操作gtf文件" class="headerlink" title="Linux神器之grep,awk操作gtf文件"></a>Linux神器之grep,awk操作gtf文件</h1><h2 id="过滤-开头注释行"><a href="#过滤-开头注释行" class="headerlink" title="过滤#开头注释行"></a>过滤#开头注释行</h2><pre><code>grep -v ^# Homo_sapiens.GRCh38.89.chr.gtf |head -5
</code></pre><p>补充：</p>
<ul>
<li><p>-v:反向选择</p>
</li>
<li><p>过滤空行：grep -v ‘^$’  filename</p>
</li>
<li><p>过滤空行和以#开头的行:  grep -vE ‘^#|^$’ filename</p>
</li>
<li><p>-E表示“或”的关系。</p>
</li>
</ul>
<h2 id="提取并计数有多少类feature"><a href="#提取并计数有多少类feature" class="headerlink" title="提取并计数有多少类feature"></a>提取并计数有多少类feature</h2><pre><code>grep -v ^# Homo_sapiens.GRCh38.89.chr.gtf |awk &apos;{print $3}&apos;| sort | uniq -c
</code></pre><p>结果：</p>
<pre><code>710166 CDS
1193694 exon
143497 five_prime_utr
58174 gene
119 Selenocysteine
83231 start_codon
74952 stop_codon
136436 three_prime_utr
199167 transcript
</code></pre><p>（第一列为数目，第二列为features）</p>
<h2 id="筛选出特定行"><a href="#筛选出特定行" class="headerlink" title="筛选出特定行"></a>筛选出特定行</h2><p>第一列为染色体1-22加X,Y的行</p>
<pre><code>awk &apos;$1 ~ /[0-9]/ || $1 ~ /[X|Y]/&apos; Homo_sapiens.GRCh38.89.chr.gtf | tail -5
</code></pre><p>第三列为”gene”的行</p>
<pre><code>awk &apos;$3==&quot;gene&quot;&apos; Homo_sapiens.GRCh38.89.chr.gtf |head -5
</code></pre><p>查看每条染色体多少个基因</p>
<pre><code>awk &apos;$1 ~ /[0-9]/ || $1 ~ /[X|Y]/&apos; Homo_sapiens.GRCh38.89.chr.gtf | awk &apos;$3==&quot;gene&quot;&apos;| awk &apos;{print $1}&apos;| sort | uniq -c
</code></pre><p>结果：</p>
<pre><code>5224 1
2208 10
3248 11
2952 12
1312 13
2214 14
2155 15
2509 16
3018 17
1174 18
2951 19
3971 2
1391 20
837 21
1339 22
3019 3
2504 4
2869 5
2860 6
2884 7
2367 8
2246 9
2366 X
519 Y
</code></pre><p>（第一列为数目，第二列为染色体号）</p>
<h2 id="先过滤出基因，然后按照chr顺序排序然后根据基因起始位置排序"><a href="#先过滤出基因，然后按照chr顺序排序然后根据基因起始位置排序" class="headerlink" title="先过滤出基因，然后按照chr顺序排序然后根据基因起始位置排序"></a>先过滤出基因，然后按照chr顺序排序然后根据基因起始位置排序</h2><pre><code>awk &apos;$1 ~ /[0-9]/ || $1 ~ /[X|Y]/ &amp;&amp; $3==&quot;gene&quot;&apos;Homo_sapiens.GRCh38.89.chr.gtf|sort -t &apos;\t&apos; -k1,1n -k4,4n &gt;result_gene_sort.txt
</code></pre><p>(因为根据asc码排序，所以X,Y会排在1-22之前)</p>
<pre><code>awk &apos;$1 ~ /[0-9]/ &amp;&amp; $3==&quot;gene&quot;&apos; Homo_sapiens.GRCh38.89.chr.gtf | sort -t $&apos;\t&apos; -k1,1n -k4,4n &gt;result_gene_sort.txt

awk &apos;$1 ~ /[X|Y]/ &amp;&amp; $3==&quot;gene&quot;&apos; Homo_sapiens.GRCh38.89.chr.gtf |sort -t $&apos;\t&apos; -k1,1 -k4,4n &gt;&gt;result_gene_sort.txt
</code></pre><p>sort 参数：</p>
<ul>
<li>-k  选择以哪个区间进行排序</li>
<li>-n   依照数值的大小排序</li>
</ul>
<p>sort多字段的排序:</p>
<ul>
<li>-t $’\t’ 指定使用tab键分列</li>
<li>-k1,1n   指定以第一列按照数字（asc码）从大到小排序</li>
<li>-k4,4n   指定以第一列按照数字（asc码）从大到小排序</li>
</ul>
<h2 id="计算所有CDS的累积长度，其他类似"><a href="#计算所有CDS的累积长度，其他类似" class="headerlink" title="计算所有CDS的累积长度，其他类似"></a>计算所有CDS的累积长度，其他类似</h2><pre><code>cat Homo_sapiens.GRCh38.89.chr.gtf | awk &apos;$3 ==&quot;CDS&quot; { len=$5-$4 + 1; size += len; print &quot;Size:&quot;, size } &apos;
</code></pre><p>（结果输出刷屏了！！加上个 |tail -1）</p>
<h2 id="计算1号染色体cds的平均长度"><a href="#计算1号染色体cds的平均长度" class="headerlink" title="计算1号染色体cds的平均长度"></a>计算1号染色体cds的平均长度</h2><pre><code>awk &apos;BEGIN  {s = 0;line = 0 } ;$3 ==&quot;CDS&quot; &amp;&amp; $1 ==&quot;1&quot; { s += ($5 - $4);line += 1}; END {print &quot;mean=&quot; s/line}&apos; Homo_sapiens.GRCh38.89.chr.gtf
</code></pre><p>补充：</p>
<p>awk的BEGIN和END</p>
<p>通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。</p>
<p>总结一下awk基本结构为 : </p>
<ul>
<li><p>BEGIN{BEGIN操作,在输入文件之前执行} ;</p>
</li>
<li><p>{文件行处理块,对来自输入文件datafile的每一行都要执行一遍} ;</p>
</li>
<li><p>END{END操作,输入文件关闭后awk退出之前执行}</p>
</li>
</ul>
<h2 id="从gtf文件中分离提取基因名字"><a href="#从gtf文件中分离提取基因名字" class="headerlink" title="从gtf文件中分离提取基因名字"></a>从gtf文件中分离提取基因名字</h2><pre><code>$3 == &quot;gene&quot; {
# 通过 ; 分离提取第9列

split($9, x, &quot;;&quot;)
# 基因名字是第一个元素。

# 去除基因名字旁边的双引号

name = x[1]

# 由于 &quot; 是一个特殊字符，我们必须写成 \&quot;;*反斜杠\表示转义符。

gsub(&quot;\&quot;&quot;, &quot;&quot;, name)

# 打印特征类型、基因名字以及大小。

print name, $5 - $4 + 1}
</code></pre><p>最后，我们可以写成下边这条命令:</p>
<pre><code>cat result_gene_sort.txt |awk &apos;$3 == &quot;gene&quot;{split($10,x,&quot;;&quot;);name = x[1];gsub(&quot;\&quot;&quot;, &quot;&quot;, name);print name,$5-$4+1}&apos;|head -5
</code></pre><h2 id="根据基因名列表提取gtf文件"><a href="#根据基因名列表提取gtf文件" class="headerlink" title="根据基因名列表提取gtf文件"></a>根据基因名列表提取gtf文件</h2><p>（1）shell脚本</p>
<pre><code>./sub_gtf.sh gene.txt Homo_sapiens.GRCh38.89.chr.gtf &gt;logfile 2&gt;&amp;1

#!/bin/bash

set -u
set -e
set -o pipefail

if [[ $# != 2 ]];then
     echo &quot;Parameter incorrect.&quot;
    exit 1
fi

gene_file=$1
gtf_file=$2


gene=($(cat ${gene_file}))
for gene in ${gene[@]}; do
   grep &quot;\&quot;${gene}\&quot;&quot; ${gtf_file} &gt;&gt;result.txt
done
</code></pre><p>（2）单行命令</p>
<pre><code>gene=($(cat gene.txt));for gene in ${gene[@]}; do grep &quot;\&quot;${gene}\&quot;&quot; Homo_sapiens.GRCh38.89.chr.gtf &gt;&gt;result.txt;done
</code></pre><h1 id="补充基本语法："><a href="#补充基本语法：" class="headerlink" title="补充基本语法："></a>补充基本语法：</h1><p>&emsp;&emsp;awk擅长处理表格形式的数据。它逐行从文本中读取数据，将整行数据（record)定义为$0,然后根据指定的分隔符，将各列数据（record)分别定义为$1,$2,$3，然后使用如下结构处理数据：</p>
<pre><code>pattern1 {action1};pattern2 {action2};....
</code></pre><p>注意：</p>
<ul>
<li>如果没有定义pattern,则直接执行action；</li>
<li>如果没有提供action,则直接输出满足pattern的内容</li>
</ul>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>（1）<a href="http://www.jianshu.com/p/7af624409dcd" target="_blank" rel="external">http://www.jianshu.com/p/7af624409dcd</a></p>
<p>（2）<a href="https://mp.weixin.qq.com/s/NZCt2SR3WmCnqpb2FGcbsQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/NZCt2SR3WmCnqpb2FGcbsQ</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;Linux神器之grep,awk操作gtf文件&lt;/blockquote&gt;
    
    </summary>
    
      <category term="linux" scheme="https:///AnJingwd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https:///AnJingwd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>如何写shell脚本</title>
    <link href="https:///AnJingwd.github.io/2017/08/13/%E5%A6%82%E4%BD%95%E5%86%99shell%E8%84%9A%E6%9C%AC/"/>
    <id>https:///AnJingwd.github.io/2017/08/13/如何写shell脚本/</id>
    <published>2017-08-13T13:14:52.000Z</published>
    <updated>2017-08-17T03:12:46.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">shell代码风格规范及技巧</blockquote>


<a id="more"></a>
<h1 id="shell代码风格规范及技巧"><a href="#shell代码风格规范及技巧" class="headerlink" title="shell代码风格规范及技巧"></a>shell代码风格规范及技巧</h1><h2 id="命名有标准"><a href="#命名有标准" class="headerlink" title="命名有标准"></a>命名有标准</h2><p>文件名规范，以.sh结尾，方便识别</p>
<h2 id="编码要统一"><a href="#编码要统一" class="headerlink" title="编码要统一"></a>编码要统一</h2><p>&emsp;&emsp;在写脚本的时候尽量使用UTF-8编码，能够支持中文等一些奇奇怪怪的字符。不过虽然能写中文，但是在写注释以及打log的时候还是尽量英文，毕竟很多机器还是没有直接支持中文的，打出来可能会有乱码。</p>
<p>&emsp;&emsp;这里还尤其需要注意一点，就是当我们是在windows下用utf-8编码来写shell脚本的时候，一定要注意这个utf-8是否是有BOM的。默认情况下windows判断utf-8格式是通过在文件开头加上三个EF BB BF字节来判断的，但是在Linux中默认是无BOM的。因此如果我们是在windows下写脚本的时候，一定要注意将编码改成Utf-8无BOM，一般用notepad++之类的编辑器都能改。否则，在Linux下运行的时候就会识别到开头的三个字符，从而报一些无法识别命令的错。</p>
<h2 id="开头有shebang"><a href="#开头有shebang" class="headerlink" title="开头有shebang"></a>开头有shebang</h2><p>&emsp;&emsp;所谓shebang其实就是在很多脚本的第一行出现的以”#!”开头的注释，他指明了当我们没有指定解释器的时候默认的解释器，一般可能是下面这样：</p>
<pre><code>#!/bin/bash
</code></pre><h2 id="写出健壮Bash-Shell脚本技巧"><a href="#写出健壮Bash-Shell脚本技巧" class="headerlink" title="写出健壮Bash Shell脚本技巧"></a>写出健壮Bash Shell脚本技巧</h2><pre><code>set -x
set -e
set -u
set -o pipeline
</code></pre><p>（1）set -x会在执行每一行 shell 脚本时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。</p>
<p>（2）在”set -e”之后出现的代码，一旦出现了返回值非零，整个脚本就会立即退出。</p>
<p>&emsp;&emsp;set -e结束程序的条件比较复杂，在man bash里面，足足用了一段话描述各种情景。大多数执行都会在出错时退出，除非 shell 命令位于以下情况：</p>
<ul>
<li>一个 pipeline 的非结尾部分，比如 error | ok</li>
<li>一个组合语句的非结尾部分，比如 ok &amp;&amp; error || other</li>
<li>一连串语句的非结尾部分，比如 error; ok</li>
<li>位于判断语句内，包括test、if、while等等。</li>
</ul>
<p>（3）set -u，当你使用未初始化的变量时，让bash自动退出</p>
<p>（4）set -o pipefail 设置了这个选项以后，包含管道命令的语句的返回值，会变成最后一个返回非零的管道命令的返回值。听起来比较绕，其实也很简单：</p>
<p>例如test.sh</p>
<pre><code>set -o pipefail
ls ./a.txt |echo &quot;hi&quot; &gt;/dev/null
echo $?
</code></pre><p>运行test.sh，因为当前目录并不存在a.txt文件，输出：<br>ls: ./a.txt: No such file or directory<br>1  # 设置了set -o pipefail，返回从右往左第一个非零返回值，即ls的返回值1</p>
<p>注释掉set -o pipefail 这一行，再次运行，输出：<br>ls: ./a.txt: No such file or directory<br>0  # 没有set -o pipefail，默认返回最后一个管道命令的返回值</p>
<h2 id="工作路径"><a href="#工作路径" class="headerlink" title="工作路径"></a>工作路径</h2><p>我们会先获取当前脚本的路径，然后一这个路径为基准，去找其他的路径。</p>
<pre><code>work_dir=$1
reference=${work_dir}/data/reference/TAIR10_chr_all.fas
</code></pre><h2 id="环境变量PATH"><a href="#环境变量PATH" class="headerlink" title="环境变量PATH"></a>环境变量PATH</h2><p>一般情况下我们会将一些重要的环境变量定义在开头，确保脚本中使用的命令能被bash搜索到。</p>
<pre><code>PATH=/bin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
</code></pre><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><pre><code>chmod +x ./test.sh  #给脚本权限
./test.sh  #执行脚本
</code></pre><h2 id="Shell中的变量"><a href="#Shell中的变量" class="headerlink" title="Shell中的变量"></a>Shell中的变量</h2><ul>
<li>“=”前后不能有空格</li>
<li>定义时不用$,使用时需要$,且推荐给所有变量加上花括号{}</li>
</ul>
<h2 id="脚本的参数"><a href="#脚本的参数" class="headerlink" title="脚本的参数"></a>脚本的参数</h2><ul>
<li><p>先定义具体含义，后使用</p>
<p>  gene_file=$1</p>
<p>  ${gene_file}</p>
</li>
</ul>
<h2 id="代码有注释"><a href="#代码有注释" class="headerlink" title="代码有注释"></a>代码有注释</h2><ul>
<li>简述某一代码段的功能</li>
<li>各个函数前的说明注释</li>
</ul>
<h2 id="太长要分行"><a href="#太长要分行" class="headerlink" title="太长要分行"></a>太长要分行</h2><p>在调用某些程序的时候，参数可能会很长，这时候为了保证较好的阅读体验，我们可以用反斜杠来分行：</p>
<pre><code>./configure \
–prefix=/usr \
–sbin-path=/usr/sbin/nginx \
–conf-path=/etc/nginx/nginx.conf \
</code></pre><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>例如：</p>
<pre><code>./sub_gtf.shell gene.txt Homo_sapiens.GRCh38.89.chr.gtf &gt;logfile 2&gt;&amp;1
</code></pre><p>1  ：表示stdout标准输出，系统默认值是1，所以”&gt;logfile”等同于”1&gt;logfile”<br>2  ：表示stderr标准错误<br>&amp;  ：表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p>
<h2 id="回显"><a href="#回显" class="headerlink" title="回显"></a>回显</h2><p>例如</p>
<pre><code>if [[ $# != 2 ]];then
    echo &quot;Parameter incorrect.&quot;
    exit 1
fi
</code></pre><p>当执行：</p>
<pre><code>./sub_gtf.shell gene.txt
</code></pre><p>因为参数数目不对，输出Parameter incorrect.至屏幕</p>
<p>当执行：</p>
<pre><code>./sub_gtf.shell gene.txt &gt;logfile 2&gt;&amp;1
</code></pre><p>同样参数数目不对，但输出Parameter incorrect.至日志</p>
<h2 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h2><h3 id="巧用main函数-使得代码可读性更强"><a href="#巧用main函数-使得代码可读性更强" class="headerlink" title="巧用main函数,使得代码可读性更强"></a>巧用main函数,使得代码可读性更强</h3><pre><code>#!/bin/bash

func1(){
    #do sth
}

func2(){
#do sth
}

main(){
    func1
    func2
}
main &quot;$@&quot;
</code></pre><h3 id="考虑作用域"><a href="#考虑作用域" class="headerlink" title="考虑作用域"></a>考虑作用域</h3><p>shell中默认的变量作用域都是全局的，比如下面的脚本：</p>
<pre><code>#!/usr/bin/env bash

var=1
func(){
    var=2
}
func
echo $var
</code></pre><p>他的输出结果就是2而不是1，这样显然不符合我们的编码习惯，很容易造成一些问题。</p>
<p>&emsp;&emsp;因此，相比直接使用全局变量，我们最好使用local, readonly这类的命令，其次我们可以使用declare来声明变量。这些方式都比使用全局方式定义要好。</p>
<h4 id="local一般用于局部变量声明，多在在函数内部使用。"><a href="#local一般用于局部变量声明，多在在函数内部使用。" class="headerlink" title="local一般用于局部变量声明，多在在函数内部使用。"></a>local一般用于局部变量声明，多在在函数内部使用。</h4><p>（1）shell脚本中定义的变量是global的，其作用域从被定义的地方开始，到shell结束或被显示删除的地方为止。</p>
<p>（2）shell函数定义的变量默认是global的，其作用域从“函数被调用时执行变量定义的地方”开始，到shell结束或被显示删除处为止。函数定义的变量可以被显示定义成local的，其作用域局限于函数内。但请注意，函数的参数是local的。</p>
<p><strong>（3）如果同名，Shell函数定义的local变量会屏蔽脚本定义的global变量。所以在函数内声明的变量，请务必记得加上 local 限定词</strong></p>
<p>使用举例：</p>
<pre><code>#!/bin/bash  

function Hello()  
{  
        local text=&quot;Hello World!!!&quot; #局部变量  
        echo $text  
}  

Hello 
</code></pre><h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<p>例如：</p>
<pre><code>readonly myUrl
myUrl=&quot;http://www.runoob.com&quot;
</code></pre><h4 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h4><ul>
<li><p>-r 只读 (declare -r var1与readonly var1作用相同)</p>
<p>  declare -r var1</p>
</li>
<li><p>-i 整数  </p>
<p>  declare -i number  </p>
</li>
<li><p>-a 数组</p>
<p>  declare -a indices</p>
</li>
<li><p>-f 函数</p>
<p>  declare -f</p>
</li>
</ul>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>&emsp;&emsp;在使用函数的时候一定要注意，shell中函数的返回值只能是整数，估计是因为一般情况下一个函数的返回值通常表示这个函数的运行状态，所以一般都是0或者是１就够了，因此就设计成了这样。不过，如果非得想传递字符串，也可以通过下面变通的方法:</p>
<pre><code>func(){
    echo &quot;2333&quot;
}
res=$(func)
echo &quot;This is from $res.&quot;
</code></pre><p>这样，通过echo或者print之类的就可以做到传一些额外参数的目的。</p>
<h2 id="使用新写法"><a href="#使用新写法" class="headerlink" title="使用新写法"></a>使用新写法</h2><p>&emsp;&emsp;这里的新写法不是指有多厉害，而是指我们可能更希望使用较新引入的一些语法，更多是偏向代码风格的，比如</p>
<ul>
<li>尽量使用func(){}来定义函数，而不是func{}</li>
<li>尽量使用[[]]来代替[]</li>
<li>尽量使用$()将命令的结果赋给变量，而不是反引号</li>
<li>在复杂的场 下尽量使用printf代替echo进行回显</li>
</ul>
<p>事实上，这些新写法很多功能都比旧的写法要强大，用的时候就知道了。</p>
<h2 id="其他小tip"><a href="#其他小tip" class="headerlink" title="其他小tip"></a>其他小tip</h2><ul>
<li>读取文件时不要使用for loop而要使用while read</li>
<li>简单的if尽量使用&amp;&amp; ||，写成单行。比如[[ x &gt; 2]] &amp;&amp; echo x</li>
<li>利用/dev/null过滤不友好或者无用的输出信息</li>
</ul>
<p>例如<br>    if grep ‘pattern1’ some.file &gt; /dev/null &amp;&amp;<br>        grep ‘pattern2’ some.file &gt; dev/null<br>    then<br>        echo “found ‘pattern1’ and ‘pattern2’ in some.file”<br>    fi</p>
<p>/dev/null ：代表空设备文件</p>
<h2 id="安装shellcheck"><a href="#安装shellcheck" class="headerlink" title="安装shellcheck"></a>安装shellcheck</h2><p>ShellCheck, a static analysis tool for shell scripts</p>
<p>shellcheck 除了可以提醒语法问题以外，还能检查出 shell 脚本编写常见的 bad code。</p>
<ul>
<li>使用方式（１）网页版：</li>
</ul>
<p><a href="http://www.shellcheck.net" target="_blank" rel="external">http://www.shellcheck.net</a></p>
<p>github仓库：</p>
<p><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">https://github.com/koalaman/shellcheck</a></p>
<p>下载安装：<br>    wget -q <a href="https://storage.googleapis.com/shellcheck/shellcheck-latest.linux.x86_64.tar.xz" target="_blank" rel="external">https://storage.googleapis.com/shellcheck/shellcheck-latest.linux.x86_64.tar.xz</a><br>    xz -d shellcheck-latest.linux.x86_64.tar.xz<br>    tar -xvf shellcheck-latest.linux.x86_64.tar<br>    echo ‘export PATH=/home/wangdong/softwares/shellcheck:$PATH’&gt;&gt;~/.bashrc<br>    source ~/.bashrc</p>
<ul>
<li><p>使用方式（2）终端：</p>
<p>  shellcheck yourscipts</p>
</li>
</ul>
<p><img src="http://i.imgur.com/HREX4bE.png" alt=""></p>
<h2 id="Shell不能做什么"><a href="#Shell不能做什么" class="headerlink" title="Shell不能做什么"></a>Shell不能做什么</h2><ul>
<li>需要精密的运算的时候</li>
<li>需要语言效率很高的时候</li>
<li>需要一些网络操作的时候</li>
<li>总之Shell就是可以快速开发一个脚本简化开发流程，并不可以用来替代高级语言</li>
</ul>
<p>&emsp;&emsp;解决特定的问题要用合适的工具。知道什么时候用 shell，什么时候切换到另外一门更通用的脚本语言（比如ruby/python/perl），这也是编写可靠 shell 脚本的诀窍。如果你的任务可以组合常见的命令来完成，而且只涉及简单的数据，那么 shell 脚本就是适合的锤子。如果你的任务包含较为复杂的逻辑，而且数据结构复杂，那么你需要用ruby/python之类的语言编写脚本。</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p>（1）<a href="https://blog.mythsman.com/2017/07/23/1/" target="_blank" rel="external">https://blog.mythsman.com/2017/07/23/1/</a></p>
<p>（2）<a href="https://github.com/koalaman/shellcheck" target="_blank" rel="external">https://github.com/koalaman/shellcheck</a></p>
<p>（3）<a href="https://segmentfault.com/a/1190000006900083" target="_blank" rel="external">https://segmentfault.com/a/1190000006900083</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;shell代码风格规范及技巧&lt;/blockquote&gt;
    
    </summary>
    
      <category term="shell脚本" scheme="https:///AnJingwd.github.io/categories/shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="shell脚本" scheme="https:///AnJingwd.github.io/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>设计sanger测序引物，验证突变位点</title>
    <link href="https:///AnJingwd.github.io/2017/08/12/%E8%AE%BE%E8%AE%A1sanger%E6%B5%8B%E5%BA%8F%E5%BC%95%E7%89%A9%EF%BC%8C%E9%AA%8C%E8%AF%81%E7%AA%81%E5%8F%98%E4%BD%8D%E7%82%B9/"/>
    <id>https:///AnJingwd.github.io/2017/08/12/设计sanger测序引物，验证突变位点/</id>
    <published>2017-08-12T12:10:28.000Z</published>
    <updated>2017-08-13T02:10:26.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">在进行Variation calling 分析之后的故事</blockquote>

<a id="more"></a>
<p>&emsp;&emsp;在进行Variation calling 分析之后。首先需要进行过滤，一般基于frequency和function两方面进行突变的过滤。</p>
<ul>
<li>frequency过滤：根据千人基因组测序项目的等位基因频率预测的0.5%作为阈值，小于这一值的认为是突变，因为千人基因组对于我们检测到的变异属于健康对照，若该变异在健康对照的频率过高，则是致病突变的可能性就比较低了。</li>
<li>function过滤：一般看exonic区的non-synonymous，frameshift deletion，frameshift insertion，nonframeshift deletion，nonframeshift insertion，nonsynonymous SNV，stopgain，synonymous SNV等。</li>
</ul>
<p>&emsp;&emsp;接着需要使用IGV查看变异位点的可靠性，并没有具体的标准。</p>
<ul>
<li>一般先看看变异位点是否在reads的两端，若是，可能是接头没去干净；</li>
<li>其次看看具有该变异位点的reads占总reads的占比，一般保留&gt;50%的；</li>
<li>最后看看变异位点两端是否”干净”;</li>
<li>另外，如果有家系的数据，可以对比着看看家庭其他成员在该位点是否有相同的变异，并推测可能的遗传方式。</li>
</ul>
<p>&emsp;&emsp;当然，以上方法得到的变异只能是初步的结果，还必须通过一代测序进行突变真实性的验证，今天的正题就是如何设计sanger测序引物？</p>
<h2 id="获取指定区域DNA序列"><a href="#获取指定区域DNA序列" class="headerlink" title="获取指定区域DNA序列"></a>获取指定区域DNA序列</h2><p>网址：</p>
<p><a href="http://hgsv.washington.edu/cgi-bin/hgc?hgsid=2655438_sG5Zu9tXr3MZHMAtoJMdHACABHm4&amp;o=8420409&amp;g=getDna&amp;i=mixed&amp;c=chr21&amp;l=8420409&amp;r=8420416&amp;db=hg19&amp;hgsid=2655438_sG5Zu9tXr3MZHMAtoJMdHACABHm4" target="_blank" rel="external">http://hgsv.washington.edu/cgi-bin/hgc?hgsid=2655438_sG5Zu9tXr3MZHMAtoJMdHACABHm4&amp;o=8420409&amp;g=getDna&amp;i=mixed&amp;c=chr21&amp;l=8420409&amp;r=8420416&amp;db=hg19&amp;hgsid=2655438_sG5Zu9tXr3MZHMAtoJMdHACABHm4</a></p>
<ul>
<li>贴入位点，如chr7:74009352-74009352</li>
<li>先在UCSC中输入位点前500，后500个碱基，</li>
<li>点击get DNA ,复制结果</li>
</ul>
<p><img src="http://i.imgur.com/a9lvtK1.jpg" alt=""></p>
<h2 id="Primer-BLAST-设计引物"><a href="#Primer-BLAST-设计引物" class="headerlink" title="Primer-BLAST 设计引物"></a>Primer-BLAST 设计引物</h2><p>网址：</p>
<p><a href="https://www.ncbi.nlm.nih.gov/tools/primer-blast/" target="_blank" rel="external">https://www.ncbi.nlm.nih.gov/tools/primer-blast/</a></p>
<p><img src="http://i.imgur.com/OTC1AUe.png" alt=""></p>
<p>PCR product size 取300-500之间主要因为节省测序成本，同时，如果设计的引物没有中点在500附近的，主要可以通过调整PCR product size的上限，这样获得的产物长点就长点吧！</p>
<p><img src="http://i.imgur.com/ykhvdoP.png" alt=""></p>
<p>Get primers</p>
<p>NCBI的Primer Blast 中这里选择的Genome(reference assembly from selected organisms)实际上是GRCh38版本。细心的可能注意到了，第一步获取序列用的是hg19版本的，但没关系，还有第三步UCSC In-Silico PCR验证呢！这一步选择的是hg19版本，这一步会进行blast!所以primer blast 和另两步的版本不同对结果不会有影响。</p>
<p><img src="http://i.imgur.com/SaLCekW.png" alt=""></p>
<p>点击submit，之后比较慢，等等吧！（同时完成引物的设计和blast，主要是blast比较耗时！）</p>
<p><img src="http://i.imgur.com/z8c8Jey.png" alt=""></p>
<p>一般第一条结果比较好，但是如果给出的若干个引物中有一条的中心更趋近与500处（待检测位点位于中间有利于测序，因为一般测序结果两端50bp会出现杂峰），则最好选择这一条，翻查下面对应的引物的正反向序列。</p>
<h2 id="UCSC-In-Silico-PCR验证引物"><a href="#UCSC-In-Silico-PCR验证引物" class="headerlink" title="UCSC In-Silico PCR验证引物"></a>UCSC In-Silico PCR验证引物</h2><p>网址：</p>
<p><a href="https://genome.ucsc.edu/cgi-bin/hgPcr?hgsid=603243225_C0DlViEzt0mvZEqK0DLtJx4pfsRN" target="_blank" rel="external">https://genome.ucsc.edu/cgi-bin/hgPcr?hgsid=603243225_C0DlViEzt0mvZEqK0DLtJx4pfsRN</a></p>
<p>&emsp;&emsp;UCSC的PCR选项为电子PCR，输入引物（&gt;15bp），即可得到两引物间序列。UCSC是基于基因组而非转录组，如果两引物间隔很大，则先调节Max Product Size。UCSC自动预测的TM值是基于primer3的，跟我们用的DNAman算出来的值也比较接近，PCR时可直接使用其退火温度。</p>
<p>用法：打开UCSC中的in silicon PCR，将上下游引物分别输入，可以选择物种，基因组，产物长度等，submit即可</p>
<p><img src="http://i.imgur.com/4ktHAvf.png" alt=""></p>
<p>Submit后，如果结果只对应处一条染色体上的一个位点，且primer melting温度控制在2度左右差范围即可，如下</p>
<p><img src="http://i.imgur.com/n9k3Giq.png" alt=""></p>
<p>整理结果：</p>
<p><img src="http://i.imgur.com/Zdr7lVt.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在进行Variation calling 分析之后的故事&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NGS" scheme="https:///AnJingwd.github.io/categories/NGS/"/>
    
    
      <category term="NGS" scheme="https:///AnJingwd.github.io/tags/NGS/"/>
    
  </entry>
  
  <entry>
    <title>基因组数据下载</title>
    <link href="https:///AnJingwd.github.io/2017/08/12/%E5%8F%82%E8%80%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD/"/>
    <id>https:///AnJingwd.github.io/2017/08/12/参考基因组数据下载/</id>
    <published>2017-08-12T09:15:06.000Z</published>
    <updated>2017-08-14T15:11:18.191Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;常用到的基因组数据格式括:fasta,fastq,gff,GenBank format, EMBL format；常用的基因组数据库包括：（1）Ensembl基因组注释数据库；（2）UCUS基因组浏览器</p>
<a id="more"></a>
<p>&emsp;&emsp;常用到的基因组数据格式括:fasta,fastq,gff,GenBank format, EMBL format；常用的基因组数据库包括：（1）Ensembl基因组注释数据库；（2）UCUS基因组浏览器</p>
<h2 id="（1）通过Ensembl基因组注释数据库下载"><a href="#（1）通过Ensembl基因组注释数据库下载" class="headerlink" title="（1）通过Ensembl基因组注释数据库下载"></a>（1）通过Ensembl基因组注释数据库下载</h2><p>网址：<a href="http://www.ensembl.org/info/data/ftp/index.html" target="_blank" rel="external">http://www.ensembl.org/info/data/ftp/index.html</a></p>
<p><strong>下载数据前一定要仔细查看相应目录下的README文件</strong></p>
<h3 id="基因组序列下载"><a href="#基因组序列下载" class="headerlink" title="基因组序列下载:"></a>基因组序列下载:</h3><p>&emsp;&emsp;Ensembl提供的参考基因组有2种组装形式和3种重复序列处理方式, 分别是primary, toplevel和unmasked (dna)、soft-masked (dna_sm)和masked (dna_rm)。一般选择dna.primary或dna_sm.primary。</p>
<ul>
<li><p>为什么选择Primary<br>Primary assembly contains all toplevel sequence regions excluding haplotypes and patches. This file is best used for performing sequence similarity searcheswhere patch and haplotype sequences would confuse analysis.</p>
</li>
<li><p>为什么不选择masked<br>&emsp;&emsp;Masked基因组是指所有重复区和低复杂区被N代替的基因组序列，比对时就不会有reads比对到这些区域。一般不推荐用masked的基因组，因为它造成了信息的丢失，由此带来的一个问题是uniquely比对到masked基因组上的reads实际上可能不是unique的。而且masked基因组还会带来比对错误，使得在允许错配的情况下，本来来自重复区的reads比对到基因组的其它位置。 另外检测重复区和低复杂区的软件不可能是完美的，这就造成遮盖住的重复序列和低复杂区并不一定是100%准确和敏感的。</p>
</li>
</ul>
<p>&emsp;&emsp;soft-masked基因组是指把所有重复区和低复杂区的序列用小写字母标出的基因组，由于主要的比对软件，比如BWA、bowtie2等都忽略这些soft-mask，直接把小写字母当做大写字母比对，所以使用soft-masked基因组的比对效果和使用unmasked基因组的比对效果是相同的。</p>
<p>(1)文件命名规则： \<species>.\<assembly>.\<sequence type="">.\<id type="">.\<id>.fa.gz</id></id></sequence></assembly></species></p>
<p>species:物种的名称</p>
<p>assembly:基因组的版本</p>
<p>sequence type（主要有三类）:</p>
<ul>
<li>‘dna’ - unmasked genomic DNA sequences.</li>
<li>‘dna_rm’ - masked genomic DNA.通过RepeatMasker软件 检测弥散的重复序列和低复杂度的区域，并将重复序列使用N替代。</li>
<li>‘dna_sm’ - soft-masked genomic DNA. 指Soft-masked的DNA序列，其中的重复序列和低复杂度的区域会用其相应碱基的小写字母来表示</li>
</ul>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>（1）连续的N</p>
<pre><code>&gt;Homo_sapiens.GRCh38.dna_rm.chromosome.15.fa
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNTTAGAGACCTTGAGA
GGAATTAAACATCTCTGTGAGTATATGCTGTAGGGCTTTGCTGCACTGTCCTTGGAGGCT
</code></pre><p>（2）小写字母表示碱基</p>
<pre><code>&gt;Homo_sapiens.GRCh38.dna_sm.chromosome.X.fa
nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnctaaccctaaccctaaccct
aaccctaaccctaaccctctgaaagtggacctatcagcaggatgtgggtgggagcagatt
gacaacCCCTAGAAGAGCACCTGGTTGAtaacccagttcccatctgggatttaggggacc
aggggccctgggacagccctgtacatgagctcctggtctgtaacacagttcccctgtggg
gatttagggACTTGGGCCTTCTGTCTTTGGGATCTACTCTCTATGGGCCACACAGATATG
</code></pre><p>&emsp;&emsp;<strong>所以，使用RepeatMasker和Tandem Repeats Finder (with period of 12 or less)识别的重复在dna_rm中用大写的N表示，而在dna_sm中用小写字母表示，而非重复序列用大写字母表示。至于序列的开头和结尾，无论是dna_rm还是dna_sm，N/n表示（A,C,G,T）任意一种，也叫做Gaps，它意味着真实具体是哪一种碱基，测序平台不能确定，N/n的数目可能是不确定碱基数,都被一并maked掉了，在序列分析的时候并不会分析。</strong></p>
<h3 id="为什么要这样做呢？"><a href="#为什么要这样做呢？" class="headerlink" title="为什么要这样做呢？"></a>为什么要这样做呢？</h3><p>&emsp;&emsp;RepeatMasker是一款基于Library-based，通过相似性比对来识别重复序列，可以屏蔽序列中转座子重复序列和低复杂度序列（默认将其替换成N），几乎用于所有物种，是做基因组、非编码RNA的必备软件。<strong>在人类基因组分析当中，大约 56% 的序列会被mask；</strong> RepeatMasker在进行序列比对时可以选用常见的几种算法，包括nhmmer、cross_match、ABBlast/WUBlast、RMBlast 、Decypher（可以安装多个比对引擎，但每次只能使用其中一个）。</p>
<p>&emsp;&emsp;RepeatMasker应该是做已知repeat和TE的。基本原理是用已知repeats去blast。所以潜在的未知重复序列应该是无法用repeatmasker找到的，而在mRNA中的repeat序列也不应该用RepeatMasker找。<strong>repeatmasker的实际意义，就象这个软件的名字一样，是为了mask掉repeat。从而在查找基因，鉴定有功能的ncRNA，或者设计引物等提供一个精简的序列。毕竟用带有大量TE和repeat的序列做引物设计或者基因和蛋白功能分析，最后验证的时候只是得到了一批repeat</strong></p>
<p><strong>重复序列的种类：</strong></p>
<ul>
<li>Tandem repeats 串连重复<ul>
<li>Satellite DNA 卫星DNA</li>
<li>Variable number tandem repeat /Minisatellite 小卫星</li>
<li>Short tandem repeat（STR）/Microsatellite (Trinucleotide repeat disorders)微卫星</li>
</ul>
</li>
<li>Interspersed repeats 散落重复<ul>
<li>Transposon (Transposable elements (TEs) )转座子<ul>
<li>Retrotransposon 反转录转座子<ul>
<li>SINEs – Alu sequence, MIR 短散落元件</li>
<li>LINEs – LINE1, LINE2 长散落元件</li>
<li>LTRs – HERV, MER4, retroposon 长末端重复</li>
<li>DNA transposon DNA转座子</li>
<li>MER1, MER2, Mariners</li>
<li>TIR（Terminal Inverted Repeat） 末端方向重复</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Genomic island<ul>
<li>Genomic island</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;这种对RepeatMasker 和 Tandem Repeats Finder用小写表示的方式，可以用于UCSC的Genome Browser来展示重复序列。</p>
<p><img src="http://i.imgur.com/dAYlW8e.png" alt=""></p>
<p>id type: 可选值包括chromosome,nonchromosomal,seqlevel。</p>
<p>（1）chromosome就不用说了；</p>
<p>（2）nonchromosal中包含了暂时未能确定染色体的序列；</p>
<p>（3）seqlevel包括sequence scaffolds, chunks 或者clones三个层次。</p>
<ul>
<li>‘scaffold’：通过短的测序reads拼接组装成更大的序列—-contigs（通常来自全基因组鸟枪测序，WGS），但是还不能组成到染色体的程度。通常还需要更多的测序，来消除gaps并确定顺序（tiling path）</li>
<li>‘chunk’:当contigs序列能被组装成大的实体时，有时候必须认为的将其打断为更小的实体，称之为’chunks’。这是由于注释管道的限制并且受存储序列和注释信息的MySQL数据库的记录限制。</li>
<li>‘clone’ ：通常这是最小的序列实体。它经常与一个BAC clone或者部分区域的序列是一样的。</li>
</ul>
<p>id:实际序列的标示符，和\<id type="">对应</id></p>
<p>fa:表示文件格式为FASTA</p>
<p>gz:文件压缩方式为GUN Zip</p>
<p>toplevel文件中包含了所有的在ensembl数据库schema中被定义为toplevel的序列，包括染色体，未能组装到染色体上的区域以及含有N的haplotype/patch区域。 </p>
<p>primary_assembly文件相比于toplevel文件，减去了含有N的haplotype/patch区域。这类文件比较适合用来比对。</p>
<h3 id="除基因组注释文件（GTF或者GFF）下载"><a href="#除基因组注释文件（GTF或者GFF）下载" class="headerlink" title="除基因组注释文件（GTF或者GFF）下载"></a>除基因组注释文件（GTF或者GFF）下载</h3><p>&emsp;&emsp;例如在RNA-seq分析流程中，参考基因组序列用于reads的比对，而GTF或者GFF用于确定比对上的reads是否落在基因内，由此来相对定量基因的表达量，鉴定差异表达基因。</p>
<p>(1)文件命名规则：\<species>.\<assembly>.\<version>.gtf.gz</version></assembly></species></p>
<p>注释基因生物证据的比对（例如蛋白，cdna，RNA-seq）来组装基因组</p>
<p>对于预测的基因集：\<species>.\<assembly>.\<version>.abinitio.gtf.gz</version></assembly></species></p>
<p>这里的预测是指通过GenScan和其他的从头预测工具分析产生的基因。</p>
<h2 id="确定了需要下载什么后，那如何下载呢？"><a href="#确定了需要下载什么后，那如何下载呢？" class="headerlink" title="确定了需要下载什么后，那如何下载呢？"></a>确定了需要下载什么后，那如何下载呢？</h2><p>可以通过浏览器下载，但需要再上传到服务器；也可以通过之前介绍的多线程下载工具axel下载，速度很快。当然还可以使用ensembl提供的rsync工具下载。</p>
<h2 id="（2）通过UCSC下载基因组注释数据"><a href="#（2）通过UCSC下载基因组注释数据" class="headerlink" title="（2）通过UCSC下载基因组注释数据"></a>（2）通过UCSC下载基因组注释数据</h2><ul>
<li>Genome Browser’s “Table Browser”：</li>
</ul>
<p><a href="http://genome.ucsc.edu/cgi-bin/hgTables?command=start" target="_blank" rel="external">http://genome.ucsc.edu/cgi-bin/hgTables?command=start</a></p>
<ul>
<li>Bulk Downloads page：</li>
</ul>
<p><a href="http://hgdownload.cse.ucsc.edu/downloads.html" target="_blank" rel="external">http://hgdownload.cse.ucsc.edu/downloads.html</a></p>
<p>&emsp;&emsp;对于NGS的序列分析来说，如果没有reference genome和genome annotation下游的分析可能根本无法进行。UCSC提供的数据分为sequence和annotation两大类，对于人、小鼠在内的71种脊椎动物，可以从UCSC同时下载sequence和annotation，其他的一般只有sequence。</p>
<p><strong>基因组的版本：</strong></p>
<p>&emsp;&emsp;不同的生物信息学数据库对于基因组的命名方式各不相同。以人为例，NCBI/ENSEMBL用GRCh系列命名，而UCSC则使用hg系列命名。这两套命名系统背后的版本对应关系如下：</p>
<table>
<thead>
<tr>
<th>UCSC</th>
<th>NCBI</th>
</tr>
</thead>
<tbody>
<tr>
<td>hg18</td>
<td>GRCh36</td>
</tr>
<tr>
<td>hg19</td>
<td>GRCh37</td>
</tr>
<tr>
<td>hg38</td>
<td>GRCh38</td>
</tr>
</tbody>
</table>
<p><strong>hg系列和GRCh系列主要的差别有两处：</strong></p>
<p>（1）hg系列的染色体命名是”chr”+染色体号，而GRCh系列的染色体没有前缀的”chr”；</p>
<p>（2）hg系列序列是0-based（第一个核苷酸记0），GRCh系列是1-based（第一个核苷酸记1，两种计数方法的区别参见《基因组的坐标系统》）。</p>
<h2 id="（1）从FTP站点获取"><a href="#（1）从FTP站点获取" class="headerlink" title="（1）从FTP站点获取"></a>（1）从FTP站点获取</h2><ul>
<li>获取sequence</li>
</ul>
<p>UCSC的reference genome是分染色体保存的。</p>
<p>对于hg38来说，单个的染色体序列可以在以下网址下载：</p>
<p><a href="http://hgdownload.soe.ucsc.edu/goldenPath/hg38/chromosomes/" target="_blank" rel="external">http://hgdownload.soe.ucsc.edu/goldenPath/hg38/chromosomes/</a> </p>
<p>所有染色体打包好的文件在以下网址下载：</p>
<p><a href="http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.chromFa.tar.gz" target="_blank" rel="external">http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.chromFa.tar.gz</a> </p>
<p>如果需要下载其他版本（19/18），可以把上述链接中的hg38换成hg19/hg18。如果需要将所有的染色体序列合并到一个文件中，可以在下载完成后依次执行下列命令（POSIX compatible）：</p>
<pre><code>tar –xzvf hg38.chromFa.tar.gz
cd hg38
cat *.fa &amp;gt; hg38.fa
</code></pre><ul>
<li>获取注释</li>
</ul>
<p>UCSC提供了SNP、RepeatMask、refSeq、GENCODE等注释文件。</p>
<p>但是在UCSC的FTP站点：</p>
<p><a href="http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database" target="_blank" rel="external">http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database</a></p>
<p>这些数据被分成了两个文件——一个是.sql结尾的SQL语句文件，描述了数据表的结构和创建数据表的方法；另一个是.txt.gz结尾的数据文件。我们可以通过.sql文件来查看表的结构，再把.txt.gz格式的文件解压后转换成所需要的格式。下面是将.txt.gz的数据文件转换成gtf格式的三个例子：</p>
<p>RepeatMask</p>
<pre><code>gunzip rmsk.txt.gz
gawk &apos;OFS=&quot;\t&quot;{print $6,&quot;rmsk &quot;,$12,$7+1,$8,&quot;.&quot;,$10,&quot;.&quot;,&quot; repName \&quot;&quot;$11&quot;\&quot;; repFamily \&quot;&quot;$13&quot;\&quot;;&quot;}&apos; rmsk.txt &amp;gt; rmsk.gtf
</code></pre><p>simpleRepeat</p>
<pre><code>gunzip simpleRepeat.txt.gz
gawk &apos;OFS=&quot;\t&quot;{print $2,&quot; simpleRepeat&quot;,&quot;trf&quot;,$3+1,$4,&quot;.&quot;,&quot;+&quot;,&quot;.&quot;,&quot;name \&quot;&quot;$5&quot;\&quot;; sequence \&quot;&quot;$17&quot;\&quot;;&quot;}&apos; simpleRepeat.txt &amp;gt; simpleRepeat.gtf
</code></pre><p>RefSeq</p>
<p>&emsp;&emsp;UCSC为RefSeq和GENCODE等以genePred形式保存的注释文件提供了专门的格式转换程序——genePredToBed、genePredToGenePred、genePredToFakePsl、genePredToGtf、genePredToMafFrames</p>
<p>各自的使用方法参见：</p>
<p><a href="http://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/FOOTER" target="_blank" rel="external">http://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/FOOTER</a></p>
<p>若需将RefSeq转存为gtf格式，可参考下列命令：</p>
<pre><code>gunzip refGene.txt.gz
cut -f 2- refGene.txt | genePredToGtf -utr -source=hg38 file stdin refGene.gtf
</code></pre><h2 id="（2）从Table-Browser获取"><a href="#（2）从Table-Browser获取" class="headerlink" title="（2）从Table Browser获取"></a>（2）从Table Browser获取</h2><p>针对annotation，UCSC还通过Table Browser页面</p>
<p><a href="http://genome.ucsc.edu/cgi-bin/hgTables" target="_blank" rel="external">http://genome.ucsc.edu/cgi-bin/hgTables</a></p>
<p>提供了一个更加友好的获取方法。Table Browser的使用基本使用方法可以参考</p>
<p><a href="http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html#GettingStarted" target="_blank" rel="external">http://genome.ucsc.edu/goldenPath/help/hgTablesHelp.html#GettingStarted</a></p>
<p>为了避免和官方帮助文档的重叠，我仅在这里分享在做REP项目过程中发现的几种比较tricky的用法。</p>
<p>（1）获取GENCODE转录本ID和Gene Symbol的映射</p>
<ul>
<li>clade设置为”Mammal”, genome设置为”Human”，assembly设置为”Dec. 2013 (GRCh38/hg38)”；</li>
<li>将group设置为”Genes and Gene Predictions”，track设置为”All GENCODE V24”；</li>
<li>Table设置为”Basic (wgEncodeGencodeBasicV24)”；</li>
<li>Output format设置为”selected fields from primary and related tables”；</li>
<li>点击”get output”；</li>
<li>在新页面中勾选”name”和”name2”前的复选框；</li>
<li>点击”get output”即可；</li>
</ul>
<p>（2）获取5’UTR/3’ UTR/Coding Exons/Intron的BED文件</p>
<ul>
<li>clade设置为”Mammal”, genome设置为”Human”，assembly设置为”Dec. 2013 (GRCh38/hg38)”；</li>
<li>将group设置为”Genes and Gene Predictions”，track设置为”All GENCODE V24”；</li>
<li>Table设置为”Basic (wgEncodeGencodeBasicV24)”；</li>
<li>Output format设置为”BED – browser extensible data”；</li>
<li>点击”get output”；</li>
<li>在新页面中勾选自己需要的elements；</li>
<li>点击”get BED”即可。</li>
</ul>
<p>（3）获取指定范围的序列</p>
<p>UCSC可以通过使用符合自己需要的注释数据，然后再获取进一步的数据。操作方法如下：</p>
<ul>
<li>点击Table Browser的”add custom tracks”按钮；</li>
<li>在”Paste URLs or data”中添加数据的地址或者使用旁边的文件上传框上传文件，点击”Submit”；</li>
<li>在新页面中选择view in“Table Brower”，点击”go”，这时会跳回Table Browser；</li>
<li>这个时候将region选为“genome”，将Output format设置成”sequence”，结果可以选择“plain text”呈现或者“gzip compressed”下载，点击”get output”即可获取指定范围内的序列。</li>
</ul>
<p>（4）Table Browser使用过程中可能会遇到的问题</p>
<ul>
<li>由于抽取数据脚本执行超时（&gt;10min）或者下载地的网络不佳，下载下来的文件可能会不完整；</li>
<li>获取3’ UTR等序列时，若直接将track指定为系统自带的annotation，会有概率出现序列的start与annotation中不符的情况（0-based和1-based的杂合），建议先下载BED文件，然后通过前述的“获取指定范围的序列”来下载序列。</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>（1）为什么序列分析要repeatmasker：</p>
<p><a href="http://www.dxy.cn/bbs/topic/9424163" target="_blank" rel="external">http://www.dxy.cn/bbs/topic/9424163</a></p>
<p>（2）博耘生物：</p>
<p><a href="http://boyun.sh.cn/bio/?p=1845" target="_blank" rel="external">http://boyun.sh.cn/bio/?p=1845</a></p>
<p>（3）linux进进阶屋：</p>
<p><a href="http://sookk8.blog.51cto.com/455855/328076/" target="_blank" rel="external">http://sookk8.blog.51cto.com/455855/328076/</a></p>
<p>（4）BioDog的博客：</p>
<p><a href="https://www.yaolibio.com/2016/09/01/retrieve-genome-data-from-ucsc/" target="_blank" rel="external">https://www.yaolibio.com/2016/09/01/retrieve-genome-data-from-ucsc/</a></p>
<p>（5）6有才</p>
<p><a href="http://www.jianshu.com/p/542c78a8ee0a" target="_blank" rel="external">http://www.jianshu.com/p/542c78a8ee0a</a></p>
<p>（6）生信宝典</p>
<p><a href="https://mp.weixin.qq.com/s/2OoXy4f1t0hE8OUqsAt1kw" target="_blank" rel="external">https://mp.weixin.qq.com/s/2OoXy4f1t0hE8OUqsAt1kw</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;常用到的基因组数据格式括:fasta,fastq,gff,GenBank format, EMBL format；常用的基因组数据库包括：（1）Ensembl基因组注释数据库；（2）UCUS基因组浏览器&lt;/p&gt;
    
    </summary>
    
      <category term="NGS" scheme="https:///AnJingwd.github.io/categories/NGS/"/>
    
    
      <category term="NGS" scheme="https:///AnJingwd.github.io/tags/NGS/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程下载工具axel编译安装</title>
    <link href="https:///AnJingwd.github.io/2017/08/06/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7axel%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
    <id>https:///AnJingwd.github.io/2017/08/06/Linux多线程下载工具axel编译安装/</id>
    <published>2017-08-06T02:57:31.000Z</published>
    <updated>2017-08-14T10:23:02.113Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Axel插件是基于yum下的一个多线程下载插件。axel插件也可以当独立下载工具来使用。当成独立下载工具使用时，适用于所有Linux发行版。通过打开多个HTTP/FTP连接来将一个文件进行分段下载，从而达到加速下载的目的。对于下载大文件，该工具特别有用。同时支持断点续传，速度通常情况下是Wget的几倍。可用于CentOS、RHEL、Fedora等使用yum的Linux发行版。由于没有管理员权限，只能编译安装源码。使用Axel可以在低速网络环境里提高数倍的下载速度。</p>
<a id="more"></a>
<h1 id="Linux多线程下载工具axel编译安装"><a href="#Linux多线程下载工具axel编译安装" class="headerlink" title="Linux多线程下载工具axel编译安装"></a>Linux多线程下载工具axel编译安装</h1><p>&emsp;&emsp;Axel插件是基于yum下的一个多线程下载插件。axel插件也可以当独立下载工具来使用。当成独立下载工具使用时，适用于所有Linux发行版。通过打开多个HTTP/FTP连接来将一个文件进行分段下载，从而达到加速下载的目的。对于下载大文件，该工具特别有用。同时支持断点续传，速度通常情况下是Wget的几倍。可用于CentOS、RHEL、Fedora等使用yum的Linux发行版。由于没有管理员权限，只能编译安装源码。使用Axel可以在低速网络环境里提高数倍的下载速度。</p>
<p>官方主页:<a href="http://axel.alioth.debian.org/" target="_blank" rel="external">http://axel.alioth.debian.org/</a></p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>下载：</p>
<pre><code>wget https://sourceforge.net/projects/axel2/files/axel-2.4/axel-2.4.tar.gz

tar -xzf axel-2.4.tar.gz 

cd axel-2.4
</code></pre><p>编译安装：</p>
<pre><code>./configure --prefix=/home/u641750/axel-2.4

make &amp;&amp; make install 
</code></pre><p>添加环境变量：</p>
<pre><code>echo &apos;export PATH=/home/u641750/axel-2.4/bin:$PATH&apos;&gt;&gt;~/.bashrc

source ~/.bashrc
</code></pre><h2 id="使用参数如下："><a href="#使用参数如下：" class="headerlink" title="使用参数如下："></a>使用参数如下：</h2><ul>
<li>–max-speed=x ,  -s x 最高速度x，指定每秒的最大比特数</li>
<li>–num-connections=x , -n x 指定线程数</li>
<li>–output=f , -o f 指定另存为目录f</li>
<li>–search[=x] , -S [x] 搜索镜像 </li>
<li>–header=x , -H x 添加头文件字符串x（指定 HTTP header）</li>
<li>–user-agent=x , -U x 设置用户代理（指定 HTTP user agent</li>
<li>–no-proxy ， -N 不使用代理服务器</li>
<li>–quiet ， -q 静默模式</li>
<li>–verbose ，-v 更多状态信息</li>
<li>–alternate ， -a Alternate progress indicator</li>
<li>–help ，-h 帮助</li>
<li>–version ，-V 版本信息</li>
</ul>
<h2 id="测试例如下载Python安装包："><a href="#测试例如下载Python安装包：" class="headerlink" title="测试例如下载Python安装包："></a>测试例如下载Python安装包：</h2><pre><code>time axel -n 10 http://mirrors.sohu.com/python/3.4.1/Python-3.4.1.tar.xz
</code></pre><p><img src="http://i.imgur.com/46QnG4A.png" alt=""></p>
<pre><code>time wget http://mirrors.sohu.com/python/3.4.1/Python-3.4.1.tar.xz
</code></pre><p><img src="http://i.imgur.com/QKdKXCh.png" alt=""></p>
<p><strong>如果下载过程中下载中断可以再执行下载命令即可恢复上次的下载进度</strong></p>
<p><strong>当然，linux也还有其他的多线程下载工具，比如myget。有人测试，axel、myget支持多线程，且速度较快都在2M。断点续传对比，三个工具都支持，但wget需要增加-c参数，axel、myget再次执行命令即可。</strong></p>
<p>例如： </p>
<pre><code>wget -c http://url/iso/Centos/x86_64/CentOS-6.4-x86_64-bin-DVD1.iso
</code></pre><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>（1）<a href="http://www.ha97.com/621.html" target="_blank" rel="external">http://www.ha97.com/621.html</a></p>
<p>（2）<a href="http://man.linuxde.net/axel" target="_blank" rel="external">http://man.linuxde.net/axel</a></p>
<p>（3）Dreamway的运维点滴（推荐阅读）</p>
<p><a href="http://dreamway.blog.51cto.com/1281816/1151886/" target="_blank" rel="external">http://dreamway.blog.51cto.com/1281816/1151886/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Axel插件是基于yum下的一个多线程下载插件。axel插件也可以当独立下载工具来使用。当成独立下载工具使用时，适用于所有Linux发行版。通过打开多个HTTP/FTP连接来将一个文件进行分段下载，从而达到加速下载的目的。对于下载大文件，该工具特别有用。同时支持断点续传，速度通常情况下是Wget的几倍。可用于CentOS、RHEL、Fedora等使用yum的Linux发行版。由于没有管理员权限，只能编译安装源码。使用Axel可以在低速网络环境里提高数倍的下载速度。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https:///AnJingwd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https:///AnJingwd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>SRA数据加速下载打包解决</title>
    <link href="https:///AnJingwd.github.io/2017/08/06/SRA%E6%A0%BC%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E6%89%93%E5%8C%85%E8%A7%A3%E5%86%B3/"/>
    <id>https:///AnJingwd.github.io/2017/08/06/SRA格式数据加速下载打包解决/</id>
    <published>2017-08-05T18:27:29.000Z</published>
    <updated>2017-08-06T11:16:11.825Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;NCBI维护Short Read Archive (SRA)作为大规模平行测序（NGS）项目产生的数据仓库。这些方法在单个循环中能产生数百万碱基至千兆级碱基的数据，是标准Sanger测序仪输出的数百万倍。运用这些技术，包括新基因组的测序，捕获基因组区域测序，多个个体的完整基因组测序来寻找变异，转录组测序来研究样本可变剪切变异和表达水平，环境样本和其他宏基因组，染色质DNA结合蛋白分析等。SRA数据库可以用于搜索和展示SRA项目数据，包括SRA主页和 Entrez system。</p>
<a id="more"></a>
<p>&emsp;&emsp;NCBI维护Short Read Archive (SRA)作为大规模平行测序（NGS）项目产生的数据仓库。这些方法在单个循环中能产生数百万碱基至千兆级碱基的数据，是标准Sanger测序仪输出的数百万倍。运用这些技术，包括新基因组的测序，捕获基因组区域测序，多个个体的完整基因组测序来寻找变异，转录组测序来研究样本可变剪切变异和表达水平，环境样本和其他宏基因组，染色质DNA结合蛋白分析等。SRA数据库可以用于搜索和展示SRA项目数据，包括SRA主页和 Entrez system。</p>
<p>SRA下载方式：<br>（1）Aspera<br>（2）sratoolkit<br>（3）FTP</p>
<p>比较：通过sratoolkit，可以直接下载成fastq格式，速度比ftp快，比aspera慢。</p>
<h2 id="Aspera"><a href="#Aspera" class="headerlink" title="Aspera"></a>Aspera</h2><p>关于速铂Aspera</p>
<p>&emsp;&emsp;速铂Aspera是一套商业的高速文件传输解决方案，随着高通量数据的大量产生，从而对于大文件快速传输的需求，开始应用到生物领域，目前NCBI、EBI的SRA库都提供这样的服务。</p>
<p>&emsp;&emsp;传统的FTP、HTTP等数据传输协议都是基于TCP的，TCP在远距离数据传输中存在一些先天的不足，文件越大、距离越远，其丢包、延时等问题对于传输速度的影响就越大。</p>
<h3 id="Aspera使用的两种方式"><a href="#Aspera使用的两种方式" class="headerlink" title="Aspera使用的两种方式"></a>Aspera使用的两种方式</h3><p>（1）客户端的下载与安装</p>
<p>&emsp;&emsp;即便Aspera是商业软件，但是作为客户应用方（相对于NCBI），我们使用其客户对进行数据的上传与下载是<strong>不用支付费用的</strong>。</p>
<p>&emsp;&emsp;网页下载：速度很快，不过需要把数据再上传到服务器上，多费一道工序下载网页版AsperaConnectML-3.5.2.97180.msi安装，网页上下载SRA数据时点aspera下载链接就可以。</p>
<ul>
<li>客户端下载链接：</li>
</ul>
<p><a href="http://downloads.asperasoft.com/connect2/" target="_blank" rel="external">http://downloads.asperasoft.com/connect2/</a></p>
<p><img src="http://i.imgur.com/OIH9xU7.png" alt=""></p>
<ul>
<li>设置下载目录及速度限制等：</li>
</ul>
<p><img src="http://i.imgur.com/StRd8jT.png" alt=""></p>
<p>至此，客户端工具准备妥当了~</p>
<p>（2）使用ascp下载SRA数据：ascp是Aspera Connect的命令行程序。</p>
<p>下载与安装（<strong>不需要root或者sudo权限</strong>）：</p>
<pre><code>curl -O http://download.asperasoft.com/download/sw/connect/3.6.1/aspera-connect-3.6.1.110647-linux-64.tar.gz  
tar zxf asper-commect-3.6.1.110647-linux.tar.gz 
sh aspera-connect-2.4.7.37118-linux-64.sh  
</code></pre><p>添加环境变量：</p>
<pre><code>export PATH=&quot;/home/u641750/.aspera/connect/bin:$PATH&quot;
</code></pre><p><strong>可以将密钥备份到/home/的家目录下方便使用（后文将用到）</strong>:</p>
<pre><code>$ cp ~/.aspera/connect/etc/asperaweb_id_dsa.openssh ~/
</code></pre><p>至此，命令行工具准备妥当了~</p>
<h4 id="那么如何找到我们要下载的SRA数据呢？"><a href="#那么如何找到我们要下载的SRA数据呢？" class="headerlink" title="那么如何找到我们要下载的SRA数据呢？"></a>那么如何找到我们要下载的SRA数据呢？</h4><p>首先我们需要了解下NSBI的SRA数据结构的层次关系：</p>
<p>NCBI官网说明：<a href="https://www.ncbi.nlm.nih.gov/books/NBK7522/" target="_blank" rel="external">https://www.ncbi.nlm.nih.gov/books/NBK7522/</a></p>
<p>&emsp;&emsp;SRA数据库中的数据分为Studies, Experiments, Samples和相应的Runs四个层次。Studies有一个总体目标并可能包含数个Experiments。一个Experiments描述具体测了什么和使用的方法。它包括DNA来源信息，样本，测序平台，数据处理。每个Experiments由一个或者多个Runs组成。一个Run包含来自每个spot的reads结果。在未来，一些数据将具有相关分析。这些分析可能包括short reads组装为基因组或者转录组的contigs，现有基因组的比对，SRA数据的比对。每个水平的记录具有唯一的accession identifiers ，并且具有三个大写字母前缀：</p>
<p>&emsp;&emsp;NCBI中SRA数据结构的层次关系：</p>
<ul>
<li>Studies:<ul>
<li><strong>SRA Study accessions (prefixes SRP, DRP, ERP)</strong></li>
<li>Examples: SRP000002, DRP000617, ERP002000</li>
<li>BioProject accessions (prefixes PRJNA, PRJDB, PRJEB)</li>
<li>Examples: PRJNA111397, PRJDB90, PRJEB1976</li>
<li>dbGaP study accessions (prefix phs)</li>
<li>Example: phs000159</li>
<li>GEO Study (prefix GSE)</li>
<li>Example: GSE12578</li>
</ul>
</li>
<li>Samples:<ul>
<li><strong>SRA Sample accessions (prefixes SRS, DRS, ERS)</strong></li>
<li>Examples: SRS000013, DRS000020, ERS000016</li>
<li>BioSample accessions (prefixes SAMN, SAME)</li>
<li>Examples: SAMN00000013, SAMEA774460</li>
<li>GEO Sample (prefix GSM)</li>
<li>Example: GSM769008</li>
</ul>
</li>
<li>SRA Experiment(s)<ul>
<li><strong>SRA Experiment accessions (prefixes SRX, DRX, ERX)</strong></li>
<li>Example: SRX000002,SRX000003,SRX000004 </li>
</ul>
</li>
</ul>
<p><img src="http://i.imgur.com/GkycANK.jpg" alt=""></p>
<p>Figure 2 shows Study (SRP000095, top panel), Experiment (SRX000113, middle panel, and SRX000114), and Run (SRR000416, bottom panel) records for the 454 sequencing of James Watson’s genome by Cold Spring Harbor Laboratory. Study and Run records are displayed in the SRA browser. The corresponding Experiment records are displayed in the NCBI Entrez system as described in the next section.</p>
<p>在SRA浏览页面和Entrez可以搜索和查看SRA数据</p>
<p>Studies, Runs和它们相关的Samples可以通过SRA主页浏览和查看：</p>
<p>www.ncbi.nlm.nih.gov/Traces/sra</p>
<p>Experiment记录可以通过搜索 Entrez SRA数据库获得：</p>
<p>www.ncbi.nlm.nih.gov/sites/entrez?db=sra</p>
<h3 id="接下来具体介绍："><a href="#接下来具体介绍：" class="headerlink" title="接下来具体介绍："></a>接下来具体介绍：</h3><p>搜索地址：<a href="https://www.ncbi.nlm.nih.gov/Traces/study/" target="_blank" rel="external">https://www.ncbi.nlm.nih.gov/Traces/study/</a></p>
<p>（1）通过以上网址，查询得到SRA数据的<strong>SRA Experiment accessions (prefixes SRX, DRX, ERX)</strong></p>
<p>（2）在NCBI搜索SRA Experiment accessions，例如：SRX000004 </p>
<p><img src="http://i.imgur.com/5UijmT0.png" alt=""></p>
<p>点击Download data：</p>
<p><img src="http://i.imgur.com/HGizIwQ.png" alt=""></p>
<p>此时鼠标选中SRX实验或者任意一个SRR记录，通过Aspera client客户端下载。但这样需要等下载完再使用FTP上传到自己的服务器，前面提过，FTP速度很慢！！！</p>
<h3 id="那么如何在服务器使用ascp命令行工具下载呢？"><a href="#那么如何在服务器使用ascp命令行工具下载呢？" class="headerlink" title="那么如何在服务器使用ascp命令行工具下载呢？"></a>那么如何在服务器使用ascp命令行工具下载呢？</h3><p>命令格式：</p>
<pre><code>ascp -i &lt;path-to-asperaweb_id_dsa.openssh&gt; -k1 -QTr –l200m anonftp@ftp-private.ncbi.nlm.nih.gov:/&lt;files to transfer&gt; &lt;local destination&gt;
</code></pre><p>相关的参数</p>
<ul>
<li>–Q (for adaptive flow control) – needed for disk throttling!</li>
<li>–T to disable encryption</li>
<li>–k1 enable resume of failed transfers</li>
<li>–l (maximum bandwidth of request, try 200M and go up from there)</li>
<li>–r recursive copy</li>
<li>–i &lt;密钥文件&gt;</li>
</ul>
<p><local destination="">表明下载存放路径，一定要有，缺少会报错！！！<br><strong>关键是如何获取<files to="" transfer="">，也就是你要下载的SRR数据的地址，并且一定要保证其存在，否则会报错！！！</files></strong></local></p>
<p>将鼠标选中上图任意一个SRR文件，例如SRR00006.sra,右键，复制链接地址：<br>fasp://anonftp@ftp.ncbi.nlm.nih.gov:22<strong>/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra</strong>?auth=no&amp;port=33001&amp;bwcap=300000&amp;targetrate=100p&amp;policy=fair&amp;enc=none&amp;lockpolicy=no&amp;locktargetrate=no&amp;lockminrate=no&amp;v=2</p>
<p>摘取/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra部分即为<files to="" transfer=""></files></p>
<p><strong>网上有其他教程说<files to="" transfer="">遵循如/sra/sra-instant/reads/ByRun/sra/SRR/SRR689/SRR689250/SRR689250.sra固定的格式，但实际并非如此，比如上面的例子，所以并不能图省事硬套上述格式，还是要再win下如上述方法找到文件具体的地址，摘取<files to="" transfer="">部分，以确保文件存在，否则会报错：“ascp: no remote host specified, exiting”</files></files></strong></p>
<p>举个栗子：</p>
<p>（1）单个文件下载：</p>
<pre><code>ascp -i ~/asperaweb_id_dsa.openssh -k1 -Tr -l100m anonftp@ftp-private.ncbi.nlm.nih.gov:/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra ~
</code></pre><p>（2）批量下载：</p>
<p>观察发现，一个SRX Experiment accessions下的<files to="" transfer="">是有规律的，如win下的目录结构所示,只是后两个字段不同：<br>/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/<strong>SRR000006</strong>/<strong>SRR000006</strong></files></p>
<p>因此可以整理为下面的格式黏贴在文本SRR_Download_List_file_list.txt 中：</p>
<p>/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000006/SRR000006.sra<br>/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000009/SRR000009.sra<br>/sra/sra-instant/reads/ByExp/sra/SRX/SRX000/SRX000004/SRR000010/SRR000010.sra</p>
<p>…….等</p>
<pre><code>ascp  -i  ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp   --file-list  SRR_Download_List_file_list.txt ~
</code></pre><p>如此可以实现批量下载！</p>
<p>使用后会发现，从NCBI上下载SRA速度，一般的宽带的话，也可以达到100M/s，大大节约了下载的时间，非常给力</p>
<p><strong>注意事项：</strong></p>
<p>（1）如果报错：Error: Server aborted session: Client requests stronger encryption than server allows，那么可以参考：<a href="https://support.asperasoft.com/hc/en-us/articles/216126788-Error-Client-requests-stronger-encryption-than-server-allows" target="_blank" rel="external">https://support.asperasoft.com/hc/en-us/articles/216126788-Error-Client-requests-stronger-encryption-than-server-allows</a> 对客户端和命令行两种方式都给出了解决方案。在linux命令行下也就是加个-T参数，即：</p>
<pre><code>ascp -T -i  ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp   --file-list  SRR_Download_List_file_list.txt ./
</code></pre><p>（2）放入后台下载，这样不用担心关闭客户端，下载也停止了~</p>
<pre><code>nohup ascp -T -i  ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp   --file-list  SRR_Download_List_file_list.txt ./ &amp;
</code></pre><p>（3）aspera默认不支持断点续传，要支持这个功能添加参数：</p>
<pre><code>ascp -k1 -T -i  ~/asperaweb_id_dsa.openssh --mode recv --host ftp-private.ncbi.nlm.nih.gov --user anonftp   --file-list  SRR_Download_List_file_list.txt ./
</code></pre><p><strong>所以 ascp -i ~/asperaweb_id_dsa.openssh -k1 -Tr -l100m anonftp@ftp-private.ncbi.nlm.nih.gov:命令可以通用</strong></p>
<p>（4）从EBI上下载也类似，给个例子：</p>
<pre><code>ascp -i ~/asperaweb_id_dsa.putty era-fasp@fasp.sra.ebi.ac.uk:/vol1/ERA012/ERA012008/sff/library08_GJ6U61T06.sff
</code></pre><p>提供Aspera的数据库：</p>
<p>（1）NCBI的Sequence Read Archive (SRA), dbGaP.</p>
<p>（2）1000genomes – EBI Aspera site, the NCBI Aspera site</p>
<p>1000genomes – EBI Aspera site:</p>
<p><a href="http://www.internationalgenome.org/aspera" target="_blank" rel="external">http://www.internationalgenome.org/aspera</a></p>
<p>1000genomes – the NCBI Aspera site</p>
<p><a href="https://www.ncbi.nlm.nih.gov/projects/faspftp/1000genomes/" target="_blank" rel="external">https://www.ncbi.nlm.nih.gov/projects/faspftp/1000genomes/</a></p>
<h2 id="sra数据转为fastaq"><a href="#sra数据转为fastaq" class="headerlink" title="sra数据转为fastaq"></a>sra数据转为fastaq</h2><p>&emsp;&emsp;sra是NCBI 推出的存储高通量数据的格式，而平常我们工作用得多是fastq格式。如果需要把sra 转成fastq，则下载NCBI SRA Toolkit。</p>
<p>下载地址：<br><a href="https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?cmd=show&amp;f=software&amp;m=software&amp;s=software" target="_blank" rel="external">https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?cmd=show&amp;f=software&amp;m=software&amp;s=software</a></p>
<p>(1)下载安装（CentOS Linux 64 bit architecture）：</p>
<pre><code>curl -O https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/2.8.2-1/sratoolkit.2.8.2-1-centos_linux64.tar.gz

tar xzvf sratoolkit.2.8.2-1-centos_linux64.tar.gz

cd  sratoolkit.2.8.2-1-centos_linux64
</code></pre><p>程序都在bin目录下，来看看有什么：</p>
<pre><code>cd bin
</code></pre><p>SRA Toolkit Documentation, Frequently Used Tools:</p>
<ul>
<li><p>fastq-dump: Convert SRA data into fastq format</p>
</li>
<li><p>prefetch: Allows command-line downloading of SRA, dbGaP, and ADSP data</p>
</li>
<li><p>sam-dump: Convert SRA data to sam format</p>
</li>
<li><p>sra-pileup: Generate pileup statistics on aligned SRA data</p>
</li>
<li><p>vdb-config: Display and modify VDB configuration information</p>
</li>
<li><p>vdb-decrypt: Decrypt non-SRA dbGaP data (“phenotype data”)</p>
</li>
</ul>
<p>(2)添加环境变量</p>
<pre><code>echo &apos;export PATH=/home/wangdong/softwares/sratoolkit.2.8.2-centos_linux64/bin&apos;&gt;&gt;~/.bashrc

source ~/.bashrc
</code></pre><p>(3)使用：</p>
<h3 id="使用prefetch下载SRA数据"><a href="#使用prefetch下载SRA数据" class="headerlink" title="使用prefetch下载SRA数据"></a>使用prefetch下载SRA数据</h3><p>下载文件:</p>
<p>（1）单个下载</p>
<pre><code>prefetch SRR1553610
</code></pre><p>（2）批量下载</p>
<pre><code>for i in $(seq 58 79);do prefetch -v SRR8287$i ;done
</code></pre><p>这些文件区哪儿了？这些文件去哪里了？存在了你home目录下的一个默认文件夹里。</p>
<pre><code>ls ~/ncbi
</code></pre><p><strong>从NCBI下下来的数据，双端测序数据是放在一个文件里的，所以需要把它们重新拆解为两个文件。</strong><br>我们用程序fastq-dump来把文件拆包</p>
<pre><code>fastq-dump --split-files SRR1553610
</code></pre><p>那么我怎么知道哪些数据是双端测序的呢？上文的网址关于NSBI的SRA数据结构的Study层次对实验方法有具体介绍：网址再贴一遍：<a href="https://www.ncbi.nlm.nih.gov/Traces/study/" target="_blank" rel="external">https://www.ncbi.nlm.nih.gov/Traces/study/</a></p>
<p>小细节之拆包后文件的命名：</p>
<table>
<thead>
<tr>
<th>File name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SRR030257_1.fastq</td>
<td>Paired-end Illumina, First of pair, FASTQ format</td>
</tr>
<tr>
<td>SRR030257_2.fastq</td>
<td>Paired-end Illumina, Second of pair, FASTQ format</td>
</tr>
</tbody>
</table>
<p>因为在后续分析，mapping到RefSeq上时，单端测序和双端测序命令有些不同！需要注意下。</p>
<p>更多的说明,请参见官方的SRA下载手册:<br>NCBI: <a href="https://www.ncbi.nlm.nih.gov/books/NBK242625/" target="_blank" rel="external">https://www.ncbi.nlm.nih.gov/books/NBK242625/</a></p>
<p>EBI: <a href="http://www.ebi.ac.uk/ena/about/sra_data_download" target="_blank" rel="external">http://www.ebi.ac.uk/ena/about/sra_data_download</a></p>
<hr>
<p>最后，附上FTP下载方式：</p>
<p>三大数据库的FTP地址：</p>
<p>ensembl : ftp://ftp.ensembl.org/pub<br>NCBI : ftp://ftp.ncbi.nih.gov/genomes/<br>UCSC：ftp://hgdownload.soe.ucsc.edu/goldenPath</p>
<p>使用Xftp5 匿名登录FTP站点即可下载资源，慢点就慢点吧~有时需要下载的文件也就1-2M</p>
<p><img src="http://i.imgur.com/IMYaE6l.png" alt=""></p>
<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>（1）博耘生物：</p>
<p><a href="http://boyun.sh.cn/bio/?p=1933" target="_blank" rel="external">http://boyun.sh.cn/bio/?p=1933</a></p>
<p>（2）Keep Learning的博客</p>
<p><a href="http://blog.csdn.net/xubo245/article/details/50513201" target="_blank" rel="external">http://blog.csdn.net/xubo245/article/details/50513201</a></p>
<p>（3）郑俊娟的博客：</p>
<p><a href="http://blog.sciencenet.cn/blog-1271266-775638.html" target="_blank" rel="external">http://blog.sciencenet.cn/blog-1271266-775638.html</a></p>
<p>（4）鳉鲈的博客：</p>
<p><a href="http://blog.sina.com.cn/s/blog_71df25810102w2vf.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_71df25810102w2vf.html</a></p>
<p>（5）生信笔记的博客：</p>
<p><a href="http://www.bioinfo-scrounger.com/" target="_blank" rel="external">http://www.bioinfo-scrounger.com/</a></p>
<p>（6）Rethink的博客</p>
<p><a href="http://blog.leanote.com/post/hwoihann/how-to-download-series-of-sra-data-in-one-command" target="_blank" rel="external">http://blog.leanote.com/post/hwoihann/how-to-download-series-of-sra-data-in-one-command</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;NCBI维护Short Read Archive (SRA)作为大规模平行测序（NGS）项目产生的数据仓库。这些方法在单个循环中能产生数百万碱基至千兆级碱基的数据，是标准Sanger测序仪输出的数百万倍。运用这些技术，包括新基因组的测序，捕获基因组区域测序，多个个体的完整基因组测序来寻找变异，转录组测序来研究样本可变剪切变异和表达水平，环境样本和其他宏基因组，染色质DNA结合蛋白分析等。SRA数据库可以用于搜索和展示SRA项目数据，包括SRA主页和 Entrez system。&lt;/p&gt;
    
    </summary>
    
      <category term="NGS软件" scheme="https:///AnJingwd.github.io/categories/NGS%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="NGS软件" scheme="https:///AnJingwd.github.io/tags/NGS%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的输出python字典</title>
    <link href="https:///AnJingwd.github.io/2017/08/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BE%93%E5%87%BApython%E5%AD%97%E5%85%B8/"/>
    <id>https:///AnJingwd.github.io/2017/08/05/如何优雅的输出python字典/</id>
    <published>2017-08-04T16:19:15.000Z</published>
    <updated>2017-08-19T11:10:45.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何优雅的输出python字典"><a href="#如何优雅的输出python字典" class="headerlink" title="如何优雅的输出python字典"></a>如何优雅的输出python字典</h1><p>&emsp;&emsp;python中的字典是一种清晰的数据结构，生信学习过程中有很多统计的事儿。比如有10个样本，Variant calling 分析后需要根据每个样本，统计每种变异类型并绘图。此时就可以用到python的嵌套字典或者嵌套列表。</p>
<a id="more"></a>
<p>&emsp;&emsp;python中的字典是一种清晰的数据结构，生信学习过程中有很多统计的事儿。比如有10个样本，Variant calling 分析后需要根据每个样本，统计每种变异类型并绘图。此时就可以用到python的嵌套字典或者嵌套列表。</p>
<h2 id="（1）一层字典"><a href="#（1）一层字典" class="headerlink" title="（1）一层字典"></a>（1）一层字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gene_symbol_ENGS=&#123;<span class="string">'PKHD1'</span>: <span class="string">'ENSG00000170927'</span>, <span class="string">'ATP6V0A4'</span>: <span class="string">'ENSG00000105929'</span>, <span class="string">'TSC2'</span>: <span class="string">'ENSG00000103197'</span>&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div><div class="line">frame1 = Series(gene_symbol_ENGS)</div><div class="line">print(frame1)</div><div class="line"></div><div class="line"></div><div class="line">    ATP6V0A4    ENSG00000105929</div><div class="line">    PKHD1       ENSG00000170927</div><div class="line">    TSC2        ENSG00000103197</div><div class="line">    dtype: object</div></pre></td></tr></table></figure>
<h2 id="（2）嵌套字典"><a href="#（2）嵌套字典" class="headerlink" title="（2）嵌套字典"></a>（2）嵌套字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sample_mutation_count = &#123;<span class="string">'PDC668_vs_PDC668A2'</span>: &#123;<span class="string">'ncRNA_intronic'</span>: <span class="number">32</span>, <span class="string">'UTR5'</span>: <span class="number">6</span>, <span class="string">'ncRNA_splicing'</span>: <span class="number">0</span>, <span class="string">'exonic;splicing'</span>: <span class="number">0</span>, <span class="string">'UTR3'</span>: <span class="number">6</span>, <span class="string">'upstream;downstream'</span>: <span class="number">1</span>, <span class="string">'downstream'</span>: <span class="number">6</span>, <span class="string">'exonic'</span>: <span class="number">155</span>, <span class="string">'upstream'</span>: <span class="number">2</span>, <span class="string">'splicing'</span>: <span class="number">1</span>, <span class="string">'ncRNA_exonic'</span>: <span class="number">19</span>, <span class="string">'intergenic'</span>: <span class="number">162</span>, <span class="string">'intronic'</span>: <span class="number">162</span>&#125;, <span class="string">'PDC3748_vs_PDC3748B4'</span>: &#123;<span class="string">'ncRNA_intronic'</span>: <span class="number">21</span>, <span class="string">'UTR5'</span>: <span class="number">6</span>, <span class="string">'ncRNA_splicing'</span>: <span class="number">0</span>, <span class="string">'exonic;splicing'</span>: <span class="number">0</span>, <span class="string">'UTR3'</span>: <span class="number">2</span>, <span class="string">'upstream;downstream'</span>: <span class="number">0</span>, <span class="string">'downstream'</span>: <span class="number">2</span>, <span class="string">'exonic'</span>: <span class="number">123</span>, <span class="string">'upstream'</span>: <span class="number">8</span>, <span class="string">'splicing'</span>: <span class="number">2</span>, <span class="string">'ncRNA_exonic'</span>: <span class="number">15</span>, <span class="string">'intergenic'</span>: <span class="number">122</span>, <span class="string">'intronic'</span>: <span class="number">130</span>&#125;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</div><div class="line">frame2 = DataFrame(sample_mutation_count)</div><div class="line">print(frame2)</div><div class="line"></div><div class="line"></div><div class="line">                         PDC3748_vs_PDC3748B4  PDC668_vs_PDC668A2</div><div class="line">    UTR3                                    <span class="number">2</span>                   <span class="number">6</span></div><div class="line">    UTR5                                    <span class="number">6</span>                   <span class="number">6</span></div><div class="line">    downstream                              <span class="number">2</span>                   <span class="number">6</span></div><div class="line">    exonic                                <span class="number">123</span>                 <span class="number">155</span></div><div class="line">    exonic;splicing                         <span class="number">0</span>                   <span class="number">0</span></div><div class="line">    intergenic                            <span class="number">122</span>                 <span class="number">162</span></div><div class="line">    intronic                              <span class="number">130</span>                 <span class="number">162</span></div><div class="line">    ncRNA_exonic                           <span class="number">15</span>                  <span class="number">19</span></div><div class="line">    ncRNA_intronic                         <span class="number">21</span>                  <span class="number">32</span></div><div class="line">    ncRNA_splicing                          <span class="number">0</span>                   <span class="number">0</span></div><div class="line">    splicing                                <span class="number">2</span>                   <span class="number">1</span></div><div class="line">    upstream                                <span class="number">8</span>                   <span class="number">2</span></div><div class="line">    upstream;downstream                     <span class="number">0</span>                   <span class="number">1</span></div><div class="line">```    </div><div class="line"></div><div class="line">那么问题来了，当每个样本的行不完全一样时如何解决呢，</div><div class="line"></div><div class="line"></div><div class="line">```python</div><div class="line">len_exon = &#123;<span class="string">'ENSG00000008710'</span>: &#123;<span class="string">'ENST00000570193'</span>: <span class="number">591</span>, <span class="string">'ENST00000483558'</span>: <span class="number">573</span>&#125;,<span class="string">'ENSG00000089597'</span>: &#123;<span class="string">'ENST00000526210'</span>: <span class="number">529</span>, <span class="string">'ENST00000526392'</span>: <span class="number">255</span>, <span class="string">'ENST00000532402'</span>: <span class="number">3695</span>&#125;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> len_exon.items():</div><div class="line">    print(key)</div><div class="line">    print(Series(value))</div><div class="line">    </div><div class="line"></div><div class="line">    ENSG00000008710</div><div class="line">    ENST00000483558    <span class="number">573</span></div><div class="line">    ENST00000570193    <span class="number">591</span></div><div class="line">    dtype: int64</div><div class="line">    ENSG00000089597</div><div class="line">    ENST00000526210     <span class="number">529</span></div><div class="line">    ENST00000526392     <span class="number">255</span></div><div class="line">    ENST00000532402    <span class="number">3695</span></div><div class="line">    dtype: int64</div><div class="line">```    </div><div class="line"></div><div class="line"><span class="comment">## 当然，也可以使用pprint输出字典结构，看着还行，但不利于后续R绘图</span></div><div class="line"></div><div class="line"></div><div class="line">```python</div><div class="line"><span class="keyword">import</span> pprint</div><div class="line">resultFile = open(<span class="string">'result.py'</span>, <span class="string">'w'</span>)</div><div class="line">resultFile.write(pprint.pformat(len_exon))</div><div class="line">resultFile.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">'ENSG00000008710'</span>: &#123;<span class="string">'ENST00000483558'</span>: <span class="number">573</span>, <span class="string">'ENST00000570193'</span>: <span class="number">591</span>&#125;,</div><div class="line"> <span class="string">'ENSG00000089597'</span>: &#123;<span class="string">'ENST00000526210'</span>: <span class="number">529</span>,</div><div class="line">                     <span class="string">'ENST00000526392'</span>: <span class="number">255</span>,</div><div class="line">                     <span class="string">'ENST00000532402'</span>: <span class="number">3695</span>&#125;&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何优雅的输出python字典&quot;&gt;&lt;a href=&quot;#如何优雅的输出python字典&quot; class=&quot;headerlink&quot; title=&quot;如何优雅的输出python字典&quot;&gt;&lt;/a&gt;如何优雅的输出python字典&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;python中的字典是一种清晰的数据结构，生信学习过程中有很多统计的事儿。比如有10个样本，Variant calling 分析后需要根据每个样本，统计每种变异类型并绘图。此时就可以用到python的嵌套字典或者嵌套列表。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https:///AnJingwd.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https:///AnJingwd.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>picard</title>
    <link href="https:///AnJingwd.github.io/2017/08/03/picard/"/>
    <id>https:///AnJingwd.github.io/2017/08/03/picard/</id>
    <published>2017-08-02T17:16:15.000Z</published>
    <updated>2017-08-06T10:46:25.925Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;picard 是用java开发的用于处理高通量测序数据和格式转换（SAM/BAM/CRAM和VCF）的命令行工具集</p>
<a id="more"></a>
<p>#Picard 高通量测序数据处理及格式转换工具大合集</p>
<p><strong>picard 是用java开发的用于处理高通量测序数据和格式转换（SAM/BAM/CRAM和VCF）的命令行工具集</strong></p>
<p>其官网为：<br><a href="http://broadinstitute.github.io/picard/" target="_blank" rel="external">http://broadinstitute.github.io/picard/</a></p>
<p>先看看picard都有哪些工具集：</p>
<h2 id="Available-Programs"><a href="#Available-Programs" class="headerlink" title="Available Programs:"></a>Available Programs:</h2><p>Alpha Tools:                                     目前无支持，需要进一步测试完善的工具集</p>
<pre><code>CollectIndependentReplicateMetrics           预测bam文件中reads的独立重复率
CollectWgsMetricsWithNonZeroCoverage         收集关于全基因组（WGS）测序的覆盖度和测序质量信息 
UmiAwareMarkDuplicatesWithMateCigar          利用read的位置和UMIs信息鉴定重复的reads
</code></pre><hr>
<p>Fasta:                                           操作FASTAor相关数据工具集</p>
<pre><code>CreateSequenceDictionary                     创建参考序列的序列字典
ExtractSequences                             从参考序列中创建子区间存为新的FASTA
NonNFastaSize                                对fasta文件中non-N碱基计数
NormalizeFasta                               规范FASTA文件中的序列行为相同长度
</code></pre><hr>
<p>Fingerprinting Tools:                            操作印迹图谱工具集</p>
<pre><code>CheckFingerprint                             计算来自提供的(SAM/BAM or VCF) 文件的指纹图谱，并与提供的基因型比较
ClusterCrosscheckMetrics                     通过LOD得分对CrosscheckFingerprints的结果进行聚类
CrosscheckFingerprints                       检查是否所有的指纹图谱来自相同的个体
CrosscheckReadGroupFingerprints              弃用：使用CrosscheckFingerprints.检查是否所有的指纹图谱来自相同的个体
</code></pre><hr>
<p>Illumina Tools:                                  操作具体Illumina测序数据工具集</p>
<pre><code>CheckIlluminaDirectory                       维护具体的Illumina basecalling数据的有效性 
CollectIlluminaBasecallingMetrics            从一次测序运行中收集Illumina Basecalling矩阵
CollectIlluminaLaneMetrics                   对于每个给定的BaseCalling分析路径收集Illumina lane矩阵 
ExtractIlluminaBarcodes                      确定Illumina lane中每个read的barcode
IlluminaBasecallsToFastq                     从Illumina basecall read数据中产生ASTQ 文件 
IlluminaBasecallsToSam                       转换原始的Illumina测序数据为unmapped 的SAM或者BAM 文件.
MarkIlluminaAdapters                         读SAM或者BAM 文件并用新的接头修饰标签重写  
</code></pre><hr>
<p>Interval Tools:                                  操作Picard区间列表工具集</p>
<pre><code>BedToIntervalList                            转换BED 文件为Picard区间列表  
IntervalListToBed                            转换Picard的IntervalList文件为BED文件.
IntervalListTools                            操作区间列表 
LiftOverIntervalList                         从一个参考转为另一个时去除区间列表
ScatterIntervalsByNs                         通过Ns分割参考，写入区间列表 
</code></pre><hr>
<p>Metrics:                                         各种不同数据类型报表矩阵工具集</p>
<pre><code>AccumulateVariantCallingMetrics              组合多个变异Calling矩阵为单个文件
CollectAlignmentSummaryMetrics               &lt;b&gt;从SAM或BAM文件产生比对矩阵总结 &lt;/b&gt;
CollectBaseDistributionByCycle               对SAM或BAM文件中每个循环核苷酸分布制表
CollectGcBiasMetrics                         收集关于GC bias的矩阵
CollectHiSeqXPfFailMetrics                   将HiSeqX Illumina Basecalling directory下的PF-Failing reads归类为不同类别
CollectHsMetrics                             从SAM或BAM文件收集杂交选择（HS）矩阵 
CollectInsertSizeMetrics                     从配对末端文库中收集插入片段分布矩阵
CollectJumpingLibraryMetrics                 收集跳跃文库矩阵 
CollectMultipleMetrics                       收集多类矩阵 
CollectOxoGMetrics                           收集矩阵评估氧化产物
CollectQualityYieldMetrics                   收集关于通过质控阈值和 Illumina-specific过滤的reads矩阵  
CollectRawWgsMetrics                         收集全基因组测序相关矩阵  
CollectRnaSeqMetrics                         从SAM或BAM文件中产生RNA比对矩阵  
CollectRrbsMetrics                           &lt;b&gt;从简化的亚硫酸氢盐测序(Rrbs)数据收集矩阵&lt;/b&gt;
CollectSequencingArtifactMetrics             收集量化单末端测序产品的矩阵 
CollectTargetedPcrMetrics                    从目标测序数据中收集PCR相关矩阵
CollectVariantCallingMetrics                 从提供的VCF文件文件中收集每个样本和包含所有样本集合的矩阵
CollectWgsMetrics                            收集关于全基因组测序（WGS）实验的覆盖度和质量矩阵
CompareMetrics                               比较两个矩阵文件
ConvertSequencingArtifactToOxoG              从广义的人工矩阵提取OxoG矩阵  
EstimateLibraryComplexity                    预测测序文库中特异性分子数量  
MeanQualityByCycle                           通过循环收集均值质量
QualityScoreDistribution                     为质量得分的分布绘制表格 
</code></pre><hr>
<p>Miscellaneous Tools:                             混杂工具集  </p>
<pre><code>BaitDesigner                                 为杂交选择反应设计寡核苷酸baits
FifoBuffer                                   FIFO buffer 用来缓冲具有可定制缓冲大小的输入和输出流
</code></pre><hr>
<p>SAM/BAM:                                         操作SAM, BAMor者相关数据的工具集</p>
<pre><code>AddCommentsToBam                             为headerBAM 文件的header增加评论
AddOrReplaceReadGroups                       替代BAM 文件的read groups
BamIndexStats                                从BAM 文件产生索引统计
BamToBfq                                     通过maq aligner从BAM文件产生BFQ文件s from a 
BuildBamIndex                                生成BAM索引，&quot;.bai&quot; 文件
CalculateReadGroupChecksum                   基于read groups(RG)产生哈希码
CheckTerminatorBlock                         维护提供的gzip 文件(e.g., BAM)最后一个区块格式正确; 否则RC 100 
CleanSam                                     清除提供的SAM/BAM，soft-clipping beyond-end-of-reference alignments并且对于未比对上的reads设置MAPQ为0
CompareSAMs                                  比较两个输入的&quot;.sam&quot; or &quot;.bam&quot; 文件 
DownsampleSam                                对SAM或BAM文件缩小取样
FastqToSam                                   转换FASTQ文件为unaligned的BAM或SAM文件
FilterSamReads                               从SAM或BAM文件取read数据子集
FixMateInformation                           如果需要，在mates和fix之间确认mate-pair信息
GatherBamFiles                               尽可能高效的连接一个或多个BAM文件
MarkDuplicates                               鉴定重复的reads 
MarkDuplicatesWithMateCigar                  鉴定重复的reads,解释mate CIGAR.  
MergeBamAlignment                            从SAM或者BAM文件中合并alignment数据到unmapped BAM文件
MergeSamFiles                                合并多个SAM和/或BAM 文件为单个文件
PositionBasedDownsampleSam                   缩小SAM或者BAM文件取样来维持reads子集，基于reads在每个flowcell的每个tile的位置
ReorderSam                                   对SAM或者BAM文件中的reads重排序，来匹配参考文件中的顺序
ReplaceSamHeader                             替代SAM或BAM文件的SAMFileHeader
RevertOriginalBaseQualitiesAndAddMateCigar   转换原始碱基质量并增加mate cigar到read-group BAMs
RevertSam                                    转换SAM或BAM 文件回到之前状态
SamFormatConverter                           BAM文件与SAM 文件互相转换
SamToFastq                                   转换SAM或者BAM文件为FASTQ文件
SetNmAndUqTags                               弃用：使用SetNmMdAndUqTags代替
SetNmMdAndUqTags                             修改SAM文件中NM,MD和UQ标签  
SortSam                                      对一个SAM或BAM文件排序 
SplitSamByLibrary                            通过文库分割SAM或BAM文件为独立文件
ValidateSamFile                              确认SAM或BAM文件
ViewSam                                      打印SAM或BAM文件到屏幕
</code></pre><hr>
<p>Unit Testing:                                    测试单元  </p>
<pre><code>SimpleMarkDuplicatesWithMateCigar            测试提供的SAM或BAM文件中比对上的记录来定位重复分子
</code></pre><hr>
<p>VCF/BCF:                                         操作VCF, BCFor者相关数据的工具集</p>
<pre><code>FilterVcf                                    严格过滤VCF
FindMendelianViolations                      在VCF文件中寻找所有违反孟德尔法则的类型
FixVcfHeader                                 代替或者修改VCF header
GatherVcfs                                   文件从一个分散的多个VCF文件产生单个VCF文件
GenotypeConcordance                          评估callsets之间的基因型一致性
LiftoverVcf                                  从一个引用构建另一个引用时留下一个VCF文件 
MakeSitesOnlyVcf                             从VCF或BCF文件创建没有基因型信息的VCF文件
MergeVcfs                                    合并多个VCF或者BCF文件为一个VCF文件或者BCF文件
RenameSampleInVcf                            对VCF或BCF中样本重命名  
SortVcf                                      对一个活多个VCF 文件排序  
SplitVcfs                                    分割SNPs和INDELs为独立的文件
UpdateVcfSequenceDictionary                  对于VCF文件和包含有序列字典的文件，利用新的序列字典更新VCF文件
VcfFormatConverter                           VCF与BCF互相转换
VcfToIntervalList                            转换VCF or BCF 文件为Picard区间列表
</code></pre><p><strong>（1）接下来看看如何安装：</strong></p>
<p>#查看Java版本</p>
<pre><code>java -version
</code></pre><p>Java 1.8及以后版本即OK</p>
<p>#从github拷贝库</p>
<pre><code>git clone https://github.com/broadinstitute/picard.git
</code></pre><p>#进入picard文件目录</p>
<pre><code>cd picard/
</code></pre><p><img src="http://i.imgur.com/j6MWTRq.png" alt=""></p>
<p>#编译<br>    ./gradlew shadowJar</p>
<p><img src="http://i.imgur.com/nBNGCE6.png" alt=""></p>
<p>此时，在build/libs/文件夹下可见picard.jar程序</p>
<p>#运行<br>    java -jar build/libs/picard.jar</p>
<p><strong>（2）如何设置环境变量：</strong></p>
<pre><code>vim ~/.bashrc
i
PICARD=&apos;/home/u631758/biosoftwares/picard/build/libs/picard.jar&apos;
alias picard=&quot;java -jar $PICARD&quot;
</code></pre><p>如此就可以用picard命名代替官网中的java -jar picard.jar命令了！！！</p>
<p><strong>（3）查看有哪些可用的工具：</strong></p>
<pre><code>picard 
</code></pre><p><strong>（4）查看某个工具的具体用法：</strong></p>
<p> 例如VcfFormatConverter工具：</p>
<pre><code>picard VcfFormatConverter -h
</code></pre><p>结果为：</p>
<pre><code>java -jar picard.jar VcfFormatConverter \
  I=input.vcf \
  O=output.bcf \
</code></pre><p>所以使用方式为：</p>
<pre><code>picard VcfFormatConverter I=input.vcf O=output.bcf
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;picard 是用java开发的用于处理高通量测序数据和格式转换（SAM/BAM/CRAM和VCF）的命令行工具集&lt;/p&gt;
    
    </summary>
    
      <category term="NGS软件" scheme="https:///AnJingwd.github.io/categories/NGS%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="NGS软件" scheme="https:///AnJingwd.github.io/tags/NGS%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>linux中python2和python3环境搭建及共存</title>
    <link href="https:///AnJingwd.github.io/2017/08/03/python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https:///AnJingwd.github.io/2017/08/03/python环境搭建/</id>
    <published>2017-08-02T16:53:42.000Z</published>
    <updated>2017-08-06T11:10:28.346Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本教程将展示如何在CentOS上通过源码编辑安装最新的Python 2 和 Python 3。以下例子使用Python 2.7.13 and Python 3.6.2，但是操作流程对于其他新版python都是相同的。</p>
<a id="more"></a>
<h1 id="linux中python2和python3环境搭建及共存"><a href="#linux中python2和python3环境搭建及共存" class="headerlink" title="linux中python2和python3环境搭建及共存"></a>linux中python2和python3环境搭建及共存</h1><p>&emsp;&emsp;如果你使用的是CentOS 6，你可以使用本教程安装 Python 2.7.x and Python 3.6.x。对于CentOS 7 只有Python 3.6.x的安装方法是适用的。警告！不要在CentOS 7上使用本教程安装Python 2.7.13。这样你的系统将有两个不同的python2.7二进制文件，每个具有自己的安装包路径。这将可能造成不能区分的问题！</p>
<h2 id="查看linux系统版本信息："><a href="#查看linux系统版本信息：" class="headerlink" title="查看linux系统版本信息："></a>查看linux系统版本信息：</h2><pre><code>lsb_release -a
</code></pre><p><strong>注: 这个命令适用于所有的linux，包括Redhat、SuSE、Debian等发行版</strong></p>
<h2 id="问题所在？"><a href="#问题所在？" class="headerlink" title="问题所在？"></a>问题所在？</h2><p>&emsp;&emsp;CentOS携带Python作为基础系统的一个重要部分。因为其十分重要，所以未及时更新，或者为了避免安全漏洞。缺少更新，意味着CentOS 6用户无法摆脱2010年8月发布的Python 2.6.6，CentOS 7用户无法摆脱2013年发布的Python 2.7.5。</p>
<p>通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变</p>
<pre><code>cd /usr/bin
ls |grep ^p
</code></pre><p><strong>只安装了python2.6</strong></p>
<h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>&emsp;&emsp;YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，避免了手动安装的麻烦(寻找资源、下载；放到指定目录安装；处理依赖关系并下载依赖关系的包进行安装)。所以用yum安装，实质上是用RPM安装，所以RPM查询信息的指令都可用。</p>
<p>如果使用RPM安装了一些包，一般来说，RPM默认安装路径如下：</p>
<p>Directory    Contents of Directory</p>
<ul>
<li>/usr/bin    一些可执行文件</li>
<li>/usr/lib    一些程序使用的动态函数库</li>
<li>/usr/share/doc    一些基本的软件使用手册与帮助文档</li>
<li>/usr/share/man    一些man page文件<br>所以没有root权限，是没有办法通过yum进行软件安装的</li>
</ul>
<p>需要考虑的事项：使用 “make altinstall” 来避免麻烦</p>
<p>&emsp;&emsp;当安装定制版的Python时使用make altinstall时十分重要的。如果使用常规的make install的结局是安装不同的python版本，但出现在文件系统中却出现同为python的程序,这将导致很难辨别的麻烦。</p>
<p>&emsp;&emsp;编译安装的准备 为了编译Python之前最好先安装一系列的开发工具和一些拓展库，但不是必须的，但这样Python才能依赖这些工具和拓展库展示它强悍的功能。</p>
<h3 id="1-下载并编译安装python"><a href="#1-下载并编译安装python" class="headerlink" title="(1)下载并编译安装python"></a>(1)下载并编译安装python</h3><p><strong>Python 2.7.13:</strong></p>
<pre><code>wget http://python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz
tar xf Python-2.7.13.tar.xz
cd Python-2.7.13
./configure --prefix=/home/wangdong/python/python27
make &amp;&amp; make altinstall
</code></pre><p><strong>Python 3.6.2:</strong></p>
<pre><code>wget http://python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz
tar xf Python-3.6.2.tar.xz
cd Python-3.6.2
./configure --prefix=/home/wangdong/python/python36
make &amp;&amp; make altinstall
</code></pre><h3 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="(2)设置环境变量"></a>(2)设置环境变量</h3><pre><code>echo &apos;export PATH=/home/wangdong/python/python36/bin:$PATH&apos;&gt;&gt;~/.bashrc
echo &apos;export PATH=/home/wangdong/python/python27/bin:$PATH&apos;&gt;&gt;~/.bashrc
</code></pre><p>&emsp;&emsp;注意使用python3.6, 使用python仍旧为系统预装的python版本，以后使用Python解释器时,同样需要注意使用python和python3.6调用的Python解释器是不同的！！</p>
<p><strong>linux添加环境环境变量注意事项：</strong></p>
<p>（1）=号左右两边没有空格</p>
<p>（2）路径之间用：分隔</p>
<p>（3）$PATH 表示原先设定的路径仍然有效，注意不要漏掉</p>
<p>（4）需要引号,因为用echo命令输出加引号的字符串时，将字符串原样输出</p>
<p>(3) 安装/升级pip,setuotools和wheel</p>
<h3 id="安装pip-setuotools和wheel"><a href="#安装pip-setuotools和wheel" class="headerlink" title="安装pip,setuotools和wheel"></a>安装pip,setuotools和wheel</h3><p>系统中的每个Python解释器都需要自己的pip,setuotools和wheel,安装和升级这些包最简单的方式是使用get-pip.py脚本。</p>
<p>First get the script:</p>
<pre><code>wget https://bootstrap.pypa.io/get-pip.py
</code></pre><p>Then execute it using Python 2.7 and/or Python 3.6:</p>
<pre><code>python2.7 get-pip.py

python3.6 get-pip.py
</code></pre><p><strong>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找</strong></p>
<pre><code>echo &apos;export PYTHONPATH=/home/wangdong/python/python36/lib/python3.6/site-packages&apos;&gt;&gt;~/.bashrc

echo &apos;export PYTHONPATH=/home/wangdong/python/python27/lib/python2.7/site-packages&apos;&gt;&gt;~/.bashrc

source ~/.bashrc
</code></pre><p>With pip installed you can now do things like this:</p>
<ul>
<li>pip2.7 install [packagename]</li>
<li>pip2.7 install –upgrade [packagename]</li>
<li><p>pip2.7 uninstall [packagename]</p>
</li>
<li><p>pip3.6 install [packagename]</p>
</li>
<li>pip3.6 install –upgrade [packagename]</li>
<li>pip3.6 uninstall [packagename]</li>
</ul>
<p>&emsp;&emsp;注意使用pip2.7和pip3.6安装软件不同点在于，安装文件的路径不同。pip2.7的安装路径是/home/wangdong/python/python27/lib/python2.7/site-packages，而pip3.6的安装路径是/home/wangdong/python/python36/lib/python3.6/site-packages</p>
<p>###（4）虚拟环境的使用</p>
<p>&emsp;&emsp;如果你使用Python2.7，则强烈推荐使用安装virtualenv并且学习使用它。virtualenv可以创建独立的Python环境。如果你使用Python3.3+，那么你没有必要安装virtualenv，因为其功能已经内建了。 每个独立的Python环境（又叫sandbox）能具有自己的Python版本和包。这对于多项目或者相同项目需要不同的版本的场合是十分重要的。</p>
<p>先看看virtualenv中文教程：</p>
<p><a href="http://virtualenv-chinese-docs.readthedocs.io/en/latest/#id29" target="_blank" rel="external">http://virtualenv-chinese-docs.readthedocs.io/en/latest/#id29</a></p>
<p>Install virtualenv for Python 2.7 and create a sandbox called my27project:</p>
<pre><code>pip2.7 install virtualenv
virtualenv my27project
</code></pre><p>Use the built-in functionality in Python 3.6 to create a sandbox called my36project:</p>
<pre><code>python3.6 -m venv my36project
</code></pre><p>(1)Check the system Python interpreter version:</p>
<pre><code>python --version
</code></pre><blockquote>
<p>This will show Python 2.6.6</p>
</blockquote>
<p>Activate the my27project sandbox:</p>
<pre><code>source my27project/bin/activate
</code></pre><p>(2)Check the Python version in the sandbox (it should be Python 2.7.13):</p>
<pre><code>python --version
</code></pre><blockquote>
<p>This will show Python 2.7.13</p>
</blockquote>
<p>Deactivate the sandbox:</p>
<pre><code>deactivate
</code></pre><p>Activate the my36project sandbox:</p>
<pre><code>source my36project/bin/activate
</code></pre><p>(3)Check the Python version in the sandbox (it should be Python 3.6.2): </p>
<pre><code>python --version
</code></pre><blockquote>
<p>This will show Python 3.6.2</p>
</blockquote>
<p>Deactivate the sandbox: </p>
<pre><code>deactivate
</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><h4 id="1-从（1）和（2）或者（1）和（3）的对比看出："><a href="#1-从（1）和（2）或者（1）和（3）的对比看出：" class="headerlink" title="(1) 从（1）和（2）或者（1）和（3）的对比看出："></a>(1) 从（1）和（2）或者（1）和（3）的对比看出：</h4><p>创建虚拟环境并激活后，虚拟环境的环境变量和系统的环境变量是隔离的，互不影响。</p>
<h4 id="2-创建的虚拟环境的Python解释器版本是如何指定的呢？"><a href="#2-创建的虚拟环境的Python解释器版本是如何指定的呢？" class="headerlink" title="(2) 创建的虚拟环境的Python解释器版本是如何指定的呢？"></a>(2) 创建的虚拟环境的Python解释器版本是如何指定的呢？</h4><p>先看看virtualenv用法:</p>
<p>$ virtualenv [OPTIONS] DEST_DIR<br>其中一个选项-p PYTHON_EXE, –python=PYTHON_EXE</p>
<p>&emsp;&emsp;指定所用的python解析器的版本，比如 –python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前目录下安装(/home/wangdong/python/python36/bin/python3.6或者/home/wangdong/python/python27/bin/python2.7)的python解析器</p>
<p>所以可以在python27下使用-p指定python3.6解释器创建虚拟环境：</p>
<p>反过来，对于Python3.3+ 通过venv模块创建指定python2.7虚拟环境则不行了！</p>
<p>首先看看venv模块官方文档：</p>
<p><a href="https://docs.python.org/3/library/venv.html" target="_blank" rel="external">https://docs.python.org/3/library/venv.html</a></p>
<p>需要注意的是，在Python3.3中使用”venv”命令创建的环境不包含”pip”，你需要进行手动安装。在Python3.4中改进了这一个缺陷。</p>
<p>并没有相关参数！！</p>
<p>所以类似的可以使用virtualenv解决：</p>
<p>在python36目录下：</p>
<pre><code>virtualenv my27project_test
source my27project_test/bin/activate
python 
</code></pre><blockquote>
<p>This will show Python 2.7.13</p>
</blockquote>
<p>在python36目录下：</p>
<pre><code>virtualenv -p /home/wangdong/python/python36/bin/python3.6 my36proje_test
source my36project_test/bin/activate
python 
</code></pre><blockquote>
<p>This will show Python 3.6.2</p>
</blockquote>
<h4 id="（3）在对应虚拟环境下使用对应pip安装软件："><a href="#（3）在对应虚拟环境下使用对应pip安装软件：" class="headerlink" title="（3）在对应虚拟环境下使用对应pip安装软件："></a>（3）在对应虚拟环境下使用对应pip安装软件：</h4><p>例如：</p>
<pre><code>source my36project/bin/activate

pip3.6 install numpy
</code></pre><p>&emsp;&emsp;安装路径为： ./my36project/lib/python3.6/site-packages **所以安装包也和系统是完全隔离的，二者互不影响。因此虚拟环境不再使用时，直接删除该虚拟环境即可。</p>
<pre><code>rm -rf my36project
</code></pre><p>在my27project下则使用pip2.7,其他类似。</p>
<p>####（4）接下来讲讲pip使用</p>
<p>使用清华的pip源安装包更快：</p>
<pre><code>pip3.6 install -i https://pypi.tuna.tsinghua.edu.cn/simple bcbio-gff biopython cython nose numpy pandas shove sqlalchemy python-memcached pyvcf
</code></pre><p>(不同安装包之间使用空格即可)</p>
<p>指定安装包的版本,例如：</p>
<pre><code>pip3.6 install pysam==0.7.5
</code></pre><p>卸载指定版本安装包，例如：</p>
<pre><code>pip3.6 uninstall biopython==1.70
</code></pre><p>把常用的包离线下载，然后使用pip离线安装包，例如：</p>
<pre><code>pip3.6 install pysam-0.7.5.tar.gz
</code></pre><p>查看当前环境pip已安装包列表： </p>
<pre><code>pip3.6 list
</code></pre><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p> <a href="https://danieleriksson.net/2017/02/08/how-to-install-latest-python-on-centos/" target="_blank" rel="external">https://danieleriksson.net/2017/02/08/how-to-install-latest-python-on-centos/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本教程将展示如何在CentOS上通过源码编辑安装最新的Python 2 和 Python 3。以下例子使用Python 2.7.13 and Python 3.6.2，但是操作流程对于其他新版python都是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https:///AnJingwd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https:///AnJingwd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux中python2和python3环境搭建及共存</title>
    <link href="https:///AnJingwd.github.io/2017/08/03/linux%E4%B8%ADpython2%E5%92%8Cpython3%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%85%B1%E5%AD%98/"/>
    <id>https:///AnJingwd.github.io/2017/08/03/linux中python2和python3环境搭建及共存/</id>
    <published>2017-08-02T16:53:42.000Z</published>
    <updated>2017-08-06T11:06:08.151Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;本教程将展示如何在CentOS上通过源码编辑安装最新的Python 2 和 Python 3。以下例子使用Python 2.7.13 and Python 3.6.2，但是操作流程对于其他新版python都是相同的。</p>
<a id="more"></a>
<h1 id="linux中python2和python3环境搭建及共存"><a href="#linux中python2和python3环境搭建及共存" class="headerlink" title="linux中python2和python3环境搭建及共存"></a>linux中python2和python3环境搭建及共存</h1><p>&emsp;&emsp;如果你使用的是CentOS 6，你可以使用本教程安装 Python 2.7.x and Python 3.6.x。对于CentOS 7 只有Python 3.6.x的安装方法是适用的。警告！不要在CentOS 7上使用本教程安装Python 2.7.13。这样你的系统将有两个不同的python2.7二进制文件，每个具有自己的安装包路径。这将可能造成不能区分的问题！</p>
<h2 id="查看linux系统版本信息："><a href="#查看linux系统版本信息：" class="headerlink" title="查看linux系统版本信息："></a>查看linux系统版本信息：</h2><pre><code>lsb_release -a
</code></pre><p><strong>注: 这个命令适用于所有的linux，包括Redhat、SuSE、Debian等发行版</strong></p>
<h2 id="问题所在？"><a href="#问题所在？" class="headerlink" title="问题所在？"></a>问题所在？</h2><p>&emsp;&emsp;CentOS携带Python作为基础系统的一个重要部分。因为其十分重要，所以未及时更新，或者为了避免安全漏洞。缺少更新，意味着CentOS 6用户无法摆脱2010年8月发布的Python 2.6.6，CentOS 7用户无法摆脱2013年发布的Python 2.7.5。</p>
<p>通常/usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变</p>
<pre><code>cd /usr/bin
ls |grep ^p
</code></pre><p><strong>只安装了python2.6</strong></p>
<h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><p>&emsp;&emsp;YUM（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，避免了手动安装的麻烦(寻找资源、下载；放到指定目录安装；处理依赖关系并下载依赖关系的包进行安装)。所以用yum安装，实质上是用RPM安装，所以RPM查询信息的指令都可用。</p>
<p>如果使用RPM安装了一些包，一般来说，RPM默认安装路径如下：</p>
<p>Directory    Contents of Directory</p>
<ul>
<li>/usr/bin    一些可执行文件</li>
<li>/usr/lib    一些程序使用的动态函数库</li>
<li>/usr/share/doc    一些基本的软件使用手册与帮助文档</li>
<li>/usr/share/man    一些man page文件<br>所以没有root权限，是没有办法通过yum进行软件安装的</li>
</ul>
<p>需要考虑的事项：使用 “make altinstall” 来避免麻烦</p>
<p>&emsp;&emsp;当安装定制版的Python时使用make altinstall时十分重要的。如果使用常规的make install的结局是安装不同的python版本，但出现在文件系统中却出现同为python的程序,这将导致很难辨别的麻烦。</p>
<p>&emsp;&emsp;编译安装的准备 为了编译Python之前最好先安装一系列的开发工具和一些拓展库，但不是必须的，但这样Python才能依赖这些工具和拓展库展示它强悍的功能。</p>
<h3 id="1-下载并编译安装python"><a href="#1-下载并编译安装python" class="headerlink" title="(1)下载并编译安装python"></a>(1)下载并编译安装python</h3><p><strong>Python 2.7.13:</strong></p>
<pre><code>wget http://python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz
tar xf Python-2.7.13.tar.xz
cd Python-2.7.13
./configure --prefix=/home/wangdong/python/python27
make &amp;&amp; make altinstall
</code></pre><p><strong>Python 3.6.2:</strong></p>
<pre><code>wget http://python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz
tar xf Python-3.6.2.tar.xz
cd Python-3.6.2
./configure --prefix=/home/wangdong/python/python36
make &amp;&amp; make altinstall
</code></pre><h3 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="(2)设置环境变量"></a>(2)设置环境变量</h3><pre><code>echo &apos;export PATH=/home/wangdong/python/python36/bin:$PATH&apos;&gt;&gt;~/.bashrc
echo &apos;export PATH=/home/wangdong/python/python27/bin:$PATH&apos;&gt;&gt;~/.bashrc
</code></pre><p>&emsp;&emsp;注意使用python3.6, 使用python仍旧为系统预装的python版本，以后使用Python解释器时,同样需要注意使用python和python3.6调用的Python解释器是不同的！！</p>
<p><strong>linux添加环境环境变量注意事项：</strong></p>
<p>（1）=号左右两边没有空格</p>
<p>（2）路径之间用：分隔</p>
<p>（3）$PATH 表示原先设定的路径仍然有效，注意不要漏掉</p>
<p>（4）需要引号,因为用echo命令输出加引号的字符串时，将字符串原样输出</p>
<p>(3) 安装/升级pip,setuotools和wheel</p>
<h3 id="安装pip-setuotools和wheel"><a href="#安装pip-setuotools和wheel" class="headerlink" title="安装pip,setuotools和wheel"></a>安装pip,setuotools和wheel</h3><p>系统中的每个Python解释器都需要自己的pip,setuotools和wheel,安装和升级这些包最简单的方式是使用get-pip.py脚本。</p>
<p>First get the script:</p>
<pre><code>wget https://bootstrap.pypa.io/get-pip.py
</code></pre><p>Then execute it using Python 2.7 and/or Python 3.6:</p>
<pre><code>python2.7 get-pip.py

python3.6 get-pip.py
</code></pre><p><strong>PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找</strong></p>
<pre><code>echo &apos;export PYTHONPATH=/home/wangdong/python/python36/lib/python3.6/site-packages&apos;&gt;&gt;~/.bashrc

echo &apos;export PYTHONPATH=/home/wangdong/python/python27/lib/python2.7/site-packages&apos;&gt;&gt;~/.bashrc

source ~/.bashrc
</code></pre><p>With pip installed you can now do things like this:</p>
<ul>
<li>pip2.7 install [packagename]</li>
<li>pip2.7 install –upgrade [packagename]</li>
<li><p>pip2.7 uninstall [packagename]</p>
</li>
<li><p>pip3.6 install [packagename]</p>
</li>
<li>pip3.6 install –upgrade [packagename]</li>
<li>pip3.6 uninstall [packagename]</li>
</ul>
<p>&emsp;&emsp;注意使用pip2.7和pip3.6安装软件不同点在于，安装文件的路径不同。pip2.7的安装路径是/home/wangdong/python/python27/lib/python2.7/site-packages，而pip3.6的安装路径是/home/wangdong/python/python36/lib/python3.6/site-packages</p>
<p>###（4）虚拟环境的使用</p>
<p>&emsp;&emsp;如果你使用Python2.7，则强烈推荐使用安装virtualenv并且学习使用它。virtualenv可以创建独立的Python环境。如果你使用Python3.3+，那么你没有必要安装virtualenv，因为其功能已经内建了。 每个独立的Python环境（又叫sandbox）能具有自己的Python版本和包。这对于多项目或者相同项目需要不同的版本的场合是十分重要的。</p>
<p>先看看virtualenv中文教程：</p>
<p><a href="http://virtualenv-chinese-docs.readthedocs.io/en/latest/#id29" target="_blank" rel="external">http://virtualenv-chinese-docs.readthedocs.io/en/latest/#id29</a></p>
<p>Install virtualenv for Python 2.7 and create a sandbox called my27project:</p>
<pre><code>pip2.7 install virtualenv
virtualenv my27project
</code></pre><p>Use the built-in functionality in Python 3.6 to create a sandbox called my36project:</p>
<pre><code>python3.6 -m venv my36project
</code></pre><p>(1)Check the system Python interpreter version:</p>
<pre><code>python --version
</code></pre><blockquote>
<p>This will show Python 2.6.6</p>
</blockquote>
<p>Activate the my27project sandbox:</p>
<pre><code>source my27project/bin/activate
</code></pre><p>(2)Check the Python version in the sandbox (it should be Python 2.7.13):</p>
<pre><code>python --version
</code></pre><blockquote>
<p>This will show Python 2.7.13</p>
</blockquote>
<p>Deactivate the sandbox:</p>
<pre><code>deactivate
</code></pre><p>Activate the my36project sandbox:</p>
<pre><code>source my36project/bin/activate
</code></pre><p>(3)Check the Python version in the sandbox (it should be Python 3.6.2): </p>
<pre><code>python --version
</code></pre><blockquote>
<p>This will show Python 3.6.2</p>
</blockquote>
<p>Deactivate the sandbox: </p>
<pre><code>deactivate
</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><h4 id="1-从（1）和（2）或者（1）和（3）的对比看出："><a href="#1-从（1）和（2）或者（1）和（3）的对比看出：" class="headerlink" title="(1) 从（1）和（2）或者（1）和（3）的对比看出："></a>(1) 从（1）和（2）或者（1）和（3）的对比看出：</h4><p>创建虚拟环境并激活后，虚拟环境的环境变量和系统的环境变量是隔离的，互不影响。</p>
<h4 id="2-创建的虚拟环境的Python解释器版本是如何指定的呢？"><a href="#2-创建的虚拟环境的Python解释器版本是如何指定的呢？" class="headerlink" title="(2) 创建的虚拟环境的Python解释器版本是如何指定的呢？"></a>(2) 创建的虚拟环境的Python解释器版本是如何指定的呢？</h4><p>先看看virtualenv用法:</p>
<p>$ virtualenv [OPTIONS] DEST_DIR<br>其中一个选项-p PYTHON_EXE, –python=PYTHON_EXE</p>
<p>&emsp;&emsp;指定所用的python解析器的版本，比如 –python=python2.5 就使用2.5版本的解析器创建新的隔离环境。 默认使用的是当前目录下安装(/home/wangdong/python/python36/bin/python3.6或者/home/wangdong/python/python27/bin/python2.7)的python解析器</p>
<p>所以可以在python27下使用-p指定python3.6解释器创建虚拟环境：</p>
<p>反过来，对于Python3.3+ 通过venv模块创建指定python2.7虚拟环境则不行了！</p>
<p>首先看看venv模块官方文档：</p>
<p><a href="https://docs.python.org/3/library/venv.html" target="_blank" rel="external">https://docs.python.org/3/library/venv.html</a></p>
<p>需要注意的是，在Python3.3中使用”venv”命令创建的环境不包含”pip”，你需要进行手动安装。在Python3.4中改进了这一个缺陷。</p>
<p>并没有相关参数！！</p>
<p>所以类似的可以使用virtualenv解决：</p>
<p>在python36目录下：</p>
<pre><code>virtualenv my27project_test
source my27project_test/bin/activate
python 
</code></pre><blockquote>
<p>This will show Python 2.7.13</p>
</blockquote>
<p>在python36目录下：</p>
<pre><code>virtualenv -p /home/wangdong/python/python36/bin/python3.6 my36proje_test
source my36project_test/bin/activate
python 
</code></pre><blockquote>
<p>This will show Python 3.6.2</p>
</blockquote>
<h4 id="（3）在对应虚拟环境下使用对应pip安装软件："><a href="#（3）在对应虚拟环境下使用对应pip安装软件：" class="headerlink" title="（3）在对应虚拟环境下使用对应pip安装软件："></a>（3）在对应虚拟环境下使用对应pip安装软件：</h4><p>例如：</p>
<pre><code>source my36project/bin/activate

pip3.6 install numpy
</code></pre><p>&emsp;&emsp;安装路径为： ./my36project/lib/python3.6/site-packages **所以安装包也和系统是完全隔离的，二者互不影响。因此虚拟环境不再使用时，直接删除该虚拟环境即可。</p>
<pre><code>rm -rf my36project
</code></pre><p>在my27project下则使用pip2.7,其他类似。</p>
<p>####（4）接下来讲讲pip使用</p>
<p>使用清华的pip源安装包更快：</p>
<pre><code>pip3.6 install -i https://pypi.tuna.tsinghua.edu.cn/simple bcbio-gff biopython cython nose numpy pandas shove sqlalchemy python-memcached pyvcf
</code></pre><p>(不同安装包之间使用空格即可)</p>
<p>指定安装包的版本,例如：</p>
<pre><code>pip3.6 install pysam==0.7.5
</code></pre><p>卸载指定版本安装包，例如：</p>
<pre><code>pip3.6 uninstall biopython==1.70
</code></pre><p>把常用的包离线下载，然后使用pip离线安装包，例如：</p>
<pre><code>pip3.6 install pysam-0.7.5.tar.gz
</code></pre><p>查看当前环境pip已安装包列表： </p>
<pre><code>pip3.6 list
</code></pre><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p> <a href="https://danieleriksson.net/2017/02/08/how-to-install-latest-python-on-centos/" target="_blank" rel="external">https://danieleriksson.net/2017/02/08/how-to-install-latest-python-on-centos/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;本教程将展示如何在CentOS上通过源码编辑安装最新的Python 2 和 Python 3。以下例子使用Python 2.7.13 and Python 3.6.2，但是操作流程对于其他新版python都是相同的。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https:///AnJingwd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https:///AnJingwd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>添加PATH环境变量</title>
    <link href="https:///AnJingwd.github.io/2017/08/02/%E6%B7%BB%E5%8A%A0PATH%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>https:///AnJingwd.github.io/2017/08/02/添加PATH环境变量/</id>
    <published>2017-08-02T15:57:09.000Z</published>
    <updated>2017-08-06T11:14:17.552Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Linux下想让某个命令可以全局使用，可以有两种方法来实现，具体请看下文！</p>
<a id="more"></a>
<h1 id="想让某个命令可以全局使用，可以有两种方法来实现："><a href="#想让某个命令可以全局使用，可以有两种方法来实现：" class="headerlink" title="想让某个命令可以全局使用，可以有两种方法来实现："></a>想让某个命令可以全局使用，可以有两种方法来实现：</h1><h2 id="方法一-在命令行将路径添加到-bashrc文件"><a href="#方法一-在命令行将路径添加到-bashrc文件" class="headerlink" title="方法一.在命令行将路径添加到 .bashrc文件"></a>方法一.在命令行将路径添加到 .bashrc文件</h2><pre><code>echo &apos;export PATH=~/home/biosoftwares/FastQC/bin/fastqc:$PATH&apos; &gt;&gt;~/.bashrc

source ~/.bashrc
</code></pre><p><strong>注意：</strong></p>
<p>（1）注意添加的路径是可执行文件的绝对路径，一般在bin下，可执行文件为绿色</p>
<p>（2）用echo命令输出加引号的字符串时，将字符串原样输出</p>
<p>（3）export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该次登陆操作</p>
<p>（4）&gt;&gt;以追加方式添加</p>
<p>（5） ~/.bashrc表示家目录下的.bashrc文件，为隐藏文件，使用ls -a可以查看</p>
<p>（6）使用source ~/.bashrc之前需要先回到家目录</p>
<p>（7）Source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于重新执行刚修改的<br>  初始化文件，使之立即生效，而不必注销并重新登录。用法：source filename 或 . filename</p>
<p><strong>也可以在用vim打开~/.bashrc文件直接添加</strong></p>
<pre><code>vim ~/.bashrc
i 
PATH=~/home/biosoftwares/FastQC/bin/fastqc
Esc
:x
</code></pre><p><strong>注意：</strong></p>
<p>（1）i 进入vim编辑模式</p>
<p>（2）Esc退出vim编辑模式</p>
<p>（3）:x保存修改并退出（需要在英文输入法状态下）</p>
<p>##方法二. 将目录添加到~/.bashrc 文件，比如~/bin，然后创建软连接（相当于win下的快捷方式）</p>
<p>#创建~/bin目录</p>
<pre><code>mkdir -p ~/bin
</code></pre><p>#将~/bin目录添加到PATH</p>
<pre><code>echo &apos;export PATH=~/bin:$PATH&apos;&gt;&gt;~/.bashrc
</code></pre><p>#使修改生效<br>    source ~/.bashrc</p>
<p>#在/bin下生成fastqc软连接</p>
<pre><code>ln -s ~/src/fastQC/fastqc ~/bin/fastqc
</code></pre><p><strong>注意：</strong></p>
<p>（1）mkdir -p  表示创建多级目录</p>
<p>（2）ln是link的缩写，-s选项创建软连接</p>
<p>创建软连接格式： ln/link SOURCE [TARGET]</p>
<p>创建软链接： ln/link -s SOURCE [TARGET]</p>
<p>软连接不占用磁盘空间，硬链接相当于拷贝，占磁盘空间</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Linux下想让某个命令可以全局使用，可以有两种方法来实现，具体请看下文！&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https:///AnJingwd.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https:///AnJingwd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>修改host文件-科学上网</title>
    <link href="https:///AnJingwd.github.io/2017/08/02/%E4%BF%AE%E6%94%B9host%E6%96%87%E4%BB%B6-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https:///AnJingwd.github.io/2017/08/02/修改host文件-科学上网/</id>
    <published>2017-08-02T14:21:51.000Z</published>
    <updated>2017-08-06T11:13:16.792Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Hosts文件是Windows系统中一个负责IP地址与域名快递解析的文件，以ASCLL格式保存。计算机在键入域名的时候，首先会去看看hosts文件汇总有没有关于此域名IP地址的记录。如果有，就直接登陆该网站；如果没有再查询DNS服务器。那么，为什么修改HOSTS文件可以实现翻墙呢？请看下文~</p>
<a id="more"></a>
<p>&emsp;&emsp;Hosts文件是Windows系统中一个负责IP地址与域名快递解析的文件，以ASCLL格式保存。计算机在键入域名的时候，首先会去看看hosts文件汇总有没有关于此域名IP地址的记录。如果有，就直接登陆该网站；如果没有再查询DNS服务器。<br><strong>那么，为什么修改HOSTS文件可以实现翻墙呢？</strong></p>
<p>&emsp;&emsp;无论你上网打的什么网站地址, 实际上最终总归是要转换成一个IP地址才能访问的,平时这个转换工作是有网络上的DNS服务器来完成的。但是有些时候,有些网站, 处于某些原因, 网络上的DNS服务器无法给出正确的或可用IP地址(天朝特别多, 大家懂的)。</p>
<p>&emsp;&emsp;这个时候hosts文件就可以代劳了, 你可以直接用记事本打开这文件看看就知道了, 里面一行就是一条记录, 一个IP地址接一个空格或tab, 再后面就是一个网址。它起到的作用就是直接在你本机上就把这些网址翻译成IP地址.</p>
<p>从Windows 2000开始，Windows解析名称的顺序为：<br>DNS cache –&gt; hosts 文件 –&gt; DNS Server –&gt; NetBIOS cache –&gt; WINS Server –&gt; 广播 –&gt; LMHOSTS 文件<br>hosts 文件的优先级高于 DNS Server，因此修改hosts文件可以跳过被污染的dns服务器。</p>
<p><strong>Hosts文件格式是咋样的？</strong></p>
<p><img src="http://i.imgur.com/UxzTkR0.png" alt=""></p>
<p>&emsp;&emsp;用记事本打开hosts文件，它的作用是包含IP地址和Host name(主机名)的映射关系，是一个映射IP地址和Hostname(主机名)的规定，规定要求每段只能包括一个映射关系，IP地址要放在每段的最前面，空格后再写上映射的Host name(主机名)。对于这段的映射说明用“#”分割后用文字说明。</p>
<p><strong>为啥还需要及时更新Hosts文件？</strong></p>
<p>Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。</p>
<p><strong>该Git项目持续更新可用的Hosts文件：</strong></p>
<p><a href="https://github.com/racaljk/hosts" target="_blank" rel="external">https://github.com/racaljk/hosts</a></p>
<p><strong>如何修改Hosts文件实现翻墙呢？</strong></p>
<p>（1）. 从上述Git项目中复制hosts文件内容至txt文件，命名为HOSTS, 并去掉扩展名！！！</p>
<p><img src="http://i.imgur.com/D5YBBUT.png" alt=""></p>
<p>  Win7 系统HOSTS文件位于 C:\Windows\System32\drivers\etc\hosts，没有拓展名。</p>
<p>（2）. 使之生效</p>
<p>Windows</p>
<p>开始 -&gt; 运行 -&gt; 输入cmd -&gt; 在CMD窗口输入</p>
<pre><code>ipconfig /flushdns
</code></pre><p>（3）使用谷歌浏览器随意登陆Google、Gmail、维基百科、Twitter、Facebook等，但必须使用https加密方式打开</p>
<p>谷歌香港：<a href="https://www.google.com.hk" target="_blank" rel="external">https://www.google.com.hk</a></p>
<p>谷歌：<a href="https://www.google.com/ncr" target="_blank" rel="external">https://www.google.com/ncr</a></p>
<p><strong>PS: www.google.com/ncr中的”/ncr”是什么意思?起什么作用的?</strong></p>
<p>ncr : no country redirect</p>
<p>&emsp;&emsp;If google thinks you are from a foreign country or region,it likes to redirect you to your regional google page.For most people,this makes sense.However,if you prefer the generic,english,plain version,this would be very annoying.</p>
<hr>
<p><strong>参考：</strong></p>
<p>（1）老D博客（很多黑科技~）：</p>
<p><a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" rel="external">https://laod.cn/hosts/2017-google-hosts.html</a></p>
<p>（2）新浪博客：<br><a href="http://blog.sina.com.cn/s/blog_9caf88850102xnlb.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_9caf88850102xnlb.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;Hosts文件是Windows系统中一个负责IP地址与域名快递解析的文件，以ASCLL格式保存。计算机在键入域名的时候，首先会去看看hosts文件汇总有没有关于此域名IP地址的记录。如果有，就直接登陆该网站；如果没有再查询DNS服务器。那么，为什么修改HOSTS文件可以实现翻墙呢？请看下文~&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https:///AnJingwd.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https:///AnJingwd.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>生命在于折腾之Github+HEXO搭建博客</title>
    <link href="https:///AnJingwd.github.io/2017/08/02/%E7%94%9F%E5%91%BD%E5%9C%A8%E4%BA%8E%E6%8A%98%E8%85%BE%E4%B9%8BGithub-HEXO%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https:///AnJingwd.github.io/2017/08/02/生命在于折腾之Github-HEXO搭建博客/</id>
    <published>2017-08-02T14:13:15.000Z</published>
    <updated>2017-08-06T10:45:36.727Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;生命在于折腾之Github+HEXO搭建博客</p>
<a id="more"></a>
<p>&emsp;&emsp;花了近四个小时，总算还是成功了~现在的心情是这样的：</p>
<p>  <img src="http://i.imgur.com/jZzGAPR.jpg" alt=""></p>
<h2 id="开心之余，将我的经验和踩过的坑分享给大家-首先推荐下参考的博客，基本是对的，实在大赞。"><a href="#开心之余，将我的经验和踩过的坑分享给大家-首先推荐下参考的博客，基本是对的，实在大赞。" class="headerlink" title="开心之余，将我的经验和踩过的坑分享给大家~ 首先推荐下参考的博客，基本是对的，实在大赞。"></a>开心之余，将我的经验和踩过的坑分享给大家~ 首先推荐下参考的博客，基本是对的，实在大赞。</h2><p>（1）Never_yu’s的博客：</p>
<p><a href="https://neveryu.github.io/2016/09/03/hexo-next-one/" target="_blank" rel="external">https://neveryu.github.io/2016/09/03/hexo-next-one/</a></p>
<p>（2）金石开的博客</p>
<p><a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="external">http://www.cnblogs.com/zhcncn/p/4097881.html</a></p>
<h2 id="建议主要根据上面两个博客的方法搭建，遇到问题看看这些填坑博客"><a href="#建议主要根据上面两个博客的方法搭建，遇到问题看看这些填坑博客" class="headerlink" title="建议主要根据上面两个博客的方法搭建，遇到问题看看这些填坑博客~"></a>建议主要根据上面两个博客的方法搭建，遇到问题看看这些填坑博客~</h2><p>（1）文青程序猿的博客：</p>
<p><a href="http://www.jianshu.com/p/31eb84182156" target="_blank" rel="external">http://www.jianshu.com/p/31eb84182156</a></p>
<p>（2）WebEnh的博客</p>
<p><a href="http://www.cnblogs.com/webenh/p/5792632.html" target="_blank" rel="external">http://www.cnblogs.com/webenh/p/5792632.html</a></p>
<h2 id="我的安装过程还算顺利，遇到的问题："><a href="#我的安装过程还算顺利，遇到的问题：" class="headerlink" title="我的安装过程还算顺利，遇到的问题："></a>我的安装过程还算顺利，遇到的问题：</h2><p>(1)安装nvm后node -v报错，表明环境变量问题：<br>解决：</p>
<ul>
<li>ivanyb的简书文章</li>
</ul>
<p><a href="http://www.jianshu.com/p/07c3456e875a" target="_blank" rel="external">http://www.jianshu.com/p/07c3456e875a</a></p>
<ul>
<li>孙群的博客</li>
</ul>
<p><a href="http://blog.csdn.net/iispring/article/details/8023319/" target="_blank" rel="external">http://blog.csdn.net/iispring/article/details/8023319/</a></p>
<p>（2）使用npm install -g hexo-cli命令安装Hexo，很卡，最后还报错，查了查，说因为npm被墙了。</p>
<ul>
<li><p>所以首先更改了淘宝的源：<br>  nvm node_mirror <a href="https://npm.taobao.org/mirrors/node/" target="_blank" rel="external">https://npm.taobao.org/mirrors/node/</a></p>
<p>  nvm npm_mirror <a href="https://npm.taobao.org/mirrors/npm/" target="_blank" rel="external">https://npm.taobao.org/mirrors/npm/</a></p>
</li>
</ul>
<p>参考：<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="external">https://github.com/coreybutler/nvm-windows</a></p>
<p>问题依旧！！！</p>
<ul>
<li>查了下报错：npm ERR!</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/weng423811758/article/details/51537594" target="_blank" rel="external">http://blog.csdn.net/weng423811758/article/details/51537594</a></p>
<p>因为我开了全局VPN,但依然没解决。</p>
<ul>
<li>淘宝说用cnpm代替npm：</li>
</ul>
<p>参考：<a href="https://npm.taobao.org/" target="_blank" rel="external">https://npm.taobao.org/</a></p>
<p>然并卵！！</p>
<p><strong>最后，查看node官网，后来看看其官网，推荐使用v6.11.2LTS，改为v6.11.2LTS之后就解决了（ps:开始是使用的node的最新的v8.2.1版本）</strong></p>
<p>（3）部署时报错error deployer not found:git </p>
<ul>
<li>解决：<a href="http://www.jianshu.com/p/4d2c07a330da" target="_blank" rel="external">http://www.jianshu.com/p/4d2c07a330da</a></li>
</ul>
<p>我的deploy配置</p>
<blockquote>
<p>deploy:</p>
<p>type: git</p>
<p>repository: <a href="https://github.com/AnJingwd/AnJingwd.github.io.git" target="_blank" rel="external">https://github.com/AnJingwd/AnJingwd.github.io.git</a></p>
<p>branch: master</p>
</blockquote>
<p>然后就成功了！！！</p>
<h1 id="我的博客："><a href="#我的博客：" class="headerlink" title="我的博客："></a>我的博客：</h1><p><a href="https://anjingwd.github.io/" target="_blank" rel="external">https://anjingwd.github.io/</a></p>
<h1 id="未完待续-博客将继续完善"><a href="#未完待续-博客将继续完善" class="headerlink" title="未完待续~ 博客将继续完善"></a>未完待续~ 博客将继续完善</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;生命在于折腾之Github+HEXO搭建博客&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https:///AnJingwd.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https:///AnJingwd.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
